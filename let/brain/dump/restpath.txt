# Derived relGoal facts
:a1 ex:relGoal :b1

# Emitted GET requests (skolem ids)
_:$req1: GET :b1  → body ?
_:$req11: GET :b1  → body ?
_:$req13: GET :b1  → body ?
_:$req15: GET :b1  → body ?
_:$req17: GET :b1  → body ?
_:$req19: GET :b1  → body ?
_:$req21: GET :b1  → body ?
_:$req7: GET :b1  → body ?
_:$req9: GET :b1  → body ?

=== Pretty Proof ===

[1] Facts: :a1 ex:rel1 :b1
[2] Goal: { ?S ex:relGoal ?O }
[3] Premise-Rule: Chain of 9 GET-emitting rules: rel1→rel2 (create 3 lanes), then relk→rel{k+1} for k=2..9; final also asserts relGoal // Each step copies 3 lanes and emits a GET on lane-1
[4] Step-1 (rel1→rel2): emit GET(req=_:$req1, uri=:a1, body=:b1); create lanes: (a1,b1)=(:a1,:b1), (a2,b2)=(_:$a3,_:$b4), (a3,b3)=(_:$a5,_:$b6) // Conclusion-only vars existentially created
[5] Step-2 (rel2→rel3): emit GET(req=_:$req7, uri=:a1, body=:b1); promote 3 lanes to rel3
[6] Step-3 (rel3→rel4): emit GET(req=_:$req9, uri=:a1, body=:b1); promote 3 lanes to rel4
[7] Step-4 (rel4→rel5): emit GET(req=_:$req11, uri=:a1, body=:b1); promote 3 lanes to rel5
[8] Step-5 (rel5→rel6): emit GET(req=_:$req13, uri=:a1, body=:b1); promote 3 lanes to rel6
[9] Step-6 (rel6→rel7): emit GET(req=_:$req15, uri=:a1, body=:b1); promote 3 lanes to rel7
[10] Step-7 (rel7→rel8): emit GET(req=_:$req17, uri=:a1, body=:b1); promote 3 lanes to rel8
[11] Step-8 (rel8→rel9): emit GET(req=_:$req19, uri=:a1, body=:b1); promote 3 lanes to rel9
[12] Step-9 (rel9→rel10 + relGoal): emit GET(req=_:$req21, uri=:a1, body=:b1); promote to rel10; assert relGoal(:a1,:b1)

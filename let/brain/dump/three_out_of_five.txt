:s a :3outof5
C1..C5 = 1, 0, 1, 1, 0  (sum=3)

=== Pretty Proof ===

[1] Premise-Rule: R (N3): For i∈{1..5}, true log:callWithOptional { :s :pi true. ?Ci=1 } { ?Ci=0 } ; then sum(?C1..?C5, ?C) and ?C ≥ 3 ⇒ (:s a :3outof5). // Single rule concluding the type :3outof5
[2] Goal: :s a :3outof5 // Original query
[3] Backchain [1, 2]: Reduce to establishing optional counts C1..C5, sum C, and C ≥ 3 // Goal-directed use of rule head
[4] Optional-C1 [3]: :p1: left-branch (found :s :p1 true) ⇒ 1  ⇒  C1 = 1
[5] Optional-C2 [3]: :p2: right-branch (no :s :p2 true) ⇒ 0  ⇒  C2 = 0
[6] Optional-C3 [3]: :p3: left-branch (found :s :p3 true) ⇒ 1  ⇒  C3 = 1
[7] Optional-C4 [3]: :p4: left-branch (found :s :p4 true) ⇒ 1  ⇒  C4 = 1
[8] Optional-C5 [3]: :p5: right-branch (no :s :p5 true) ⇒ 0  ⇒  C5 = 0
[9] math:sum: (1 0 1 1 0) ⇒ sum C = 3 // math:sum over (C1 C2 C3 C4 C5)
[10] math:notLessThan [9]: 3 ≥ 3  ⇒  True // Threshold holds
[11] Head-Intro [3, 10]: :s a :3outof5 // Rule applied since antecedent holds

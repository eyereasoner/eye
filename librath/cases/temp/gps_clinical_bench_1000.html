<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GPS Clinical Bench (1000) — self‑contained JS</title>
  <style>
    :root { --fg:#101014; --bg:#ffffff; --muted:#666; --accent:#2563eb; --chip:#eef2ff; }
    @media (prefers-color-scheme: dark) {
      :root { --fg:#eaeaf0; --bg:#0b0b10; --muted:#a0a0b0; --accent:#60a5fa; --chip:#0e1a32; }
    }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font: 15px/1.6 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    main { max-width: 1100px; margin: 0 auto; padding: 28px 16px 80px; }
    h1 { font-size: clamp(1.6rem, 2.6vw + 1rem, 2.2rem); margin: 0 0 6px; }
    header p { margin: 0; color: var(--muted); }
    section { margin: 18px 0 22px; padding: 14px 14px 16px; border: 1px solid color-mix(in srgb, var(--accent) 18%, transparent); border-radius: 14px;
              background: color-mix(in srgb, var(--accent) 4%, transparent); }
    section h2 { margin: 0 0 8px; font-size: 1.15rem; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:10px; }
    .chip { display:inline-block; padding:2px 8px; border-radius:999px; background:var(--chip); font-weight:600; }
    .muted { color: var(--muted); }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .btn { appearance:none; border:1px solid color-mix(in srgb, var(--accent) 35%, transparent); background: color-mix(in srgb, var(--accent) 8%, transparent);
           color: var(--fg); border-radius: 10px; padding: 8px 12px; font-weight: 700; cursor: pointer; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .tbl { width:100%; border-collapse: collapse; }
    .tbl th, .tbl td { padding: 6px 8px; border-bottom: 1px dashed color-mix(in srgb, var(--fg) 18%, transparent); vertical-align: top; }
    .tbl th { text-align:left; }
    .ok { color: #16a34a; }
    .bad { color: #dc2626; }
    .small { font-size: 0.92em; }
    code { background: color-mix(in srgb, var(--accent) 10%, transparent); padding: .1rem .35rem; border-radius: .35rem; }
    textarea { width: 100%; min-height: 180px; border-radius: 10px; padding: 8px; }
  </style>
</head>
<body>
  <main>
    <header class="row">
      <div>
        <h1>GPS Clinical Bench — 1000 rules</h1>
        <p>Self‑contained browser version: no network calls; everything runs in JavaScript.</p>
      </div>
      <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
        <button id="run" class="btn">Run with demo rules</button>
        <button id="use-embedded" class="btn">Use embedded rules → Run</button>
      </div>
    </header>

    <section>
      <h2>What this is</h2>
      <p>
        This single HTML file reproduces the benchmark’s reasoning loop in plain JavaScript.
        It parses a block of Notation3 (<code>gps:description</code>) transitions, applies
        the embedded <em>patient filters</em> (gender/age), and performs a loop‑free breadth‑first search
        under fixed limits. It then prints <strong>Answer</strong> (all valid paths),
        <strong>Reason why</strong> (why certain actions are applicable), and <strong>Check</strong>
        (a small harness that replays totals and verifies ordering).
      </p>
      <p class="small muted">
        Sorting: success (higher) → cost (lower) → duration (shorter). All offline & self‑contained.
      </p>
    </section>

    <section>
      <div class="grid">
        <div>Goal state: <span class="chip mono" id="goal">state_6</span></div>
        <div>Limits: <span class="chip mono">duration ≤ 180d</span> <span class="chip mono">cost ≤ €500</span> <span class="chip mono">success ≥ 0.35</span> <span class="chip mono">comfort ≥ 0.35</span> <span class="chip mono">stagecount ≤ 10</span></div>
      </div>
    </section>

    <section>
      <h2>Patient</h2>
      <div id="patient" class="grid"></div>
    </section>

    <section>
      <h2>Rules block (optional — keep offline)</h2>
      <p class="small muted">
        This file ships with a tiny demo ruleset so it runs out of the box. To reproduce the full
        <code>gps_clinical_bench_1000</code> dataset, paste the <em>N3 rules block</em> from the original script
        into this textbox and click “Use embedded rules → Run”. No network is used either way.
      </p>
      <textarea id="rulesbox" class="mono"></textarea>
    </section>

    <section>
      <h2>Answer</h2>
      <div id="answer"><em class="muted">Not computed yet.</em></div>
    </section>

    <section>
      <h2>Reason why</h2>
      <div id="reason"><em class="muted">Not computed yet.</em></div>
    </section>

    <section>
      <h2>Check (harness)</h2>
      <div id="check"><em class="muted">Not computed yet.</em></div>
    </section>
  </main>

  <script>
  (function(){
    // ——————————————————————————————————————————————
    // Parameters (embedded)
    // ——————————————————————————————————————————————
    const GOAL_STATE = "state_6";
    const MAX_DURATION_D = 180;
    const MAX_COST = 500.0;
    const MIN_SUCCESS_P = 0.35;
    const MIN_COMFORT_P = 0.35;
    const MAX_STAGECOUNT = 10;

    // Patient (same fields as reference)
    const PATIENT = {
      uri: "data:patient_1",
      name: "Jane Doe",
      gender: "Female",
      age: 14,
      weight: 75.0,          // not used in rules
      diagnosis: "49049000", // SNOMED
      state: "state_2"
    };

    // Minimal demo rules (N3) just to make the page produce output offline.
    // Format mirrors the original gps:description pattern.
    const DEMO_N3 = `
PREFIX math:  PREFIX xsd:  PREFIX e:  PREFIX action:  PREFIX medication:  PREFIX sct:  PREFIX care:  PREFIX gps:
{care:Parkinson gps:description (
  {?patient care:state care:state_2.}
  {?patient gps:medication medication:Medication_101.}
  {?patient care:state care:state_3.}
  action:take_pill_Medication_101 "P1D"^^xsd:dayTimeDuration 20 0.680 0.800
)} <= {
  ?patient a care:Patient. ?patient care:gender care:Female. ?patient care:age ?age.
}.
{care:Parkinson gps:description (
  {?patient care:state care:state_3.}
  {?patient gps:medication medication:Medication_202.}
  {?patient care:state care:state_6.}
  action:take_pill_Medication_202 "P1D"^^xsd:dayTimeDuration 10 0.700 0.900
)} <= {
  ?patient a care:Patient. ?patient care:gender care:Female. ?patient care:age ?age.
}.
`;

    const $ = (id) => document.getElementById(id);
    const setHTML = (id, html) => { const el = $(id); if (el) el.innerHTML = html; };

    // Show patient immediately
    setHTML("patient", `<div>Name: <span class="chip">${PATIENT.name}</span></div>
      <div>Gender: <span class="chip">${PATIENT.gender}</span></div>
      <div>Age: <span class="chip">${PATIENT.age}</span></div>
      <div>Start state: <span class="chip mono">${PATIENT.state}</span></div>`);

    // Pre-fill textarea for convenience
    $("rulesbox").value = DEMO_N3.trim();

    // ——————————————————————————————————————————————
    // Parser for N3 gps:description rules
    // ——————————————————————————————————————————————
    function parseRules(n3) {
      const rules = [];
      const ruleRe = new RegExp(
        String.raw`\{\s*care:Parkinson\s+gps:description\s+\(\s*`
        + String.raw`\{\?patient\s+care:state\s+care:(state_\d+)\.\}\s*` // from
        + String.raw`\{\?patient\s+gps:medication\s+medication:(Medication_\d+)\.\}\s*`
        + String.raw`\{\?patient\s+care:state\s+care:(state_\d+)\.\}\s*` // to
        + String.raw`action:([A-Za-z0-9_]+)\s*`
        + String.raw`"P(\d+)D"\^\^xsd:dayTimeDuration\s*`
        + String.raw`(\d+)\s*`      // cost
        + String.raw`([0-9.]+)\s*`  // success
        + String.raw`([0-9.]+)\s*`  // comfort
        + String.raw`\)\s*\}\s*<=\s*\{\s*`
        + String.raw`([\s\S]*?)\}\s*\.\s*`
      , "gs");

      const genderRe = /care:gender\s+care:(Male|Female)/;
      const minAgeRe = /math:greaterThan\s+(\d+)/;

      for (const m of n3.matchAll(ruleRe)) {
        const from_state = m[1];
        const /*medication*/ _med = m[2];
        const to_state = m[3];
        const action = m[4];
        const duration_d = parseInt(m[5], 10);
        const cost = parseFloat(m[6]);
        const success_p = parseFloat(m[7]);
        const comfort_p = parseFloat(m[8]);
        const body = m[9];

        let gender = null, minAge = null;
        const g = body.match(genderRe);
        if (g) gender = g[1];
        const a = body.match(minAgeRe);
        if (a) minAge = parseInt(a[1], 10);

        rules.push({
          from_state, to_state, action, duration_d, cost, success_p, comfort_p,
          gender, minAge,
          applies(patient, cur_state) {
            const okGender = (gender === null) || (patient.gender === gender);
            const okAge = (minAge === null) || (patient.age > minAge);
            return cur_state === from_state && okGender && okAge;
          }
        });
      }
      return rules;
    }

    // ——————————————————————————————————————————————
    // BFS search with limits (loop-free)
    // ——————————————————————————————————————————————
    function searchAll(patient, rules) {
      const start = { state: patient.state, duration: 0, cost: 0.0, succ: 1.0, comfort: 1.0, path: [] };
      const queue = [start];
      const sols = [];
      const visited = new Set(); // key is JSON([state, path])

      const key = (state, path) => JSON.stringify([state, path]);

      while (queue.length) {
        const cur = queue.shift();

        if (cur.state === GOAL_STATE) {
          sols.push(cur);
          continue;
        }
        if (cur.path.length >= MAX_STAGECOUNT) continue;

        for (const r of rules) {
          if (!r.applies(patient, cur.state)) continue;
          const nd = cur.duration + r.duration_d;
          const nc = cur.cost + r.cost;
          const ns = cur.succ * r.success_p;
          const nf = cur.comfort * r.comfort_p;
          if (!(nd <= MAX_DURATION_D && nc <= MAX_COST && ns >= MIN_SUCCESS_P && nf >= MIN_COMFORT_P)) continue;

          const nxtPath = cur.path.concat([r.action]);
          const sig = key(r.to_state, nxtPath);
          if (visited.has(sig)) continue;
          visited.add(sig);

          queue.push({ state: r.to_state, duration: nd, cost: nc, succ: ns, comfort: nf, path: nxtPath });
        }
      }
      return sols;
    }

    // ——————————————————————————————————————————————
    // Pretty printing & harness
    // ——————————————————————————————————————————————
    const fmt = {
      euros: (x) => "€" + x.toFixed(2),
      prob: (x) => x.toFixed(3),
    };

    function sortSolutions(sols) {
      sols.sort((a,b) => {
        if (a.succ !== b.succ) return b.succ - a.succ; // higher first
        if (a.cost !== b.cost) return a.cost - b.cost;  // lower first
        return a.duration - b.duration;                 // shorter first
      });
    }

    function renderSolutions(solutions) {
      if (!solutions.length) {
        return `<p class="bad">⛔ No path satisfies the limits.</p>`;
      }
      sortSolutions(solutions);

      let html = `<p class="ok">✅ Found ${solutions.length} solution path(s):</p>`;
      html += `<table class="tbl mono small"><thead><tr>
        <th>#</th><th>steps</th><th>duration</th><th>cost</th><th>success</th><th>comfort</th><th>actions</th><th>end</th>
      </tr></thead><tbody>`;
      solutions.forEach((n, i) => {
        html += `<tr>
          <td>${i+1}</td>
          <td>${n.path.length} (≤ ${MAX_STAGECOUNT})</td>
          <td>${n.duration} (≤ ${MAX_DURATION_D})</td>
          <td>${fmt.euros(n.cost)} (≤ ${fmt.euros(MAX_COST)})</td>
          <td>${fmt.prob(n.succ)} (≥ ${MIN_SUCCESS_P})</td>
          <td>${fmt.prob(n.comfort)} (≥ ${MIN_COMFORT_P})</td>
          <td>${n.path.map((a,j)=>`${j+1}. ${a}`).join("<br>")}</td>
          <td>${n.state}</td>
        </tr>`;
      });
      html += `</tbody></table>`;

      const best = solutions[0];
      html += `<p class="small">Optimal by (succ↓, cost↑, dur↑): path = <code>${best.path.join(", ")}</code>,
               succ=${fmt.prob(best.succ)}, cost=${fmt.euros(best.cost)}, dur=${best.duration}d</p>`;
      return html;
    }

    function applicableFromState(patient, rules, state) {
      return rules.filter(r => r.applies(patient, state));
    }

    function renderReason(patient, rules) {
      const apps = applicableFromState(patient, rules, patient.state);
      if (!apps.length) {
        return `<p>From the start state <code>${patient.state}</code>, applicable rules: 0 — start is a dead‑end for these demographics.</p>`;
      }
      let html = `<p>From the start state <code>${patient.state}</code>, applicable rules for this patient: ${apps.length}</p>`;
      const oneStep = apps.filter(r => r.to_state === GOAL_STATE);
      if (oneStep.length) {
        html += `<p><strong>One‑step routes to the goal:</strong></p><ul class="mono small">`;
        oneStep.forEach(r => {
          html += `<li>${r.action}: ${r.from_state} → ${r.to_state} (+${r.duration_d}d, +€${r.cost.toFixed(0)}, ×succ ${r.success_p.toFixed(3)}, ×comf ${r.comfort_p.toFixed(3)})</li>`;
        });
        html += `</ul>`;
      } else {
        html += `<p>No single step reaches the goal.</p>`;
      }
      const others = apps.filter(r => r.to_state !== GOAL_STATE).slice(0, 20);
      if (others.length) {
        html += `<p><strong>Sample of other applicable first steps (max 20 shown):</strong></p><ul class="mono small">`;
        others.forEach(r => {
          html += `<li>${r.action}: ${r.from_state} → ${r.to_state} (+${r.duration_d}d, +€${r.cost.toFixed(0)}, ×succ ${r.success_p.toFixed(3)}, ×comf ${r.comfort_p.toFixed(3)})</li>`;
        });
        html += `</ul>`;
      }
      return html;
    }

    // Harness checks mirroring the reference
    function approx(a, b, tol=1e-12) {
      const d = Math.abs(a - b);
      return d <= tol * Math.max(1.0, 1.0 + Math.abs(a) + Math.abs(b));
    }
    function leqByKey(a, b, tol=1e-12) {
      if (a.succ > b.succ + tol) return true;
      if (b.succ > a.succ + tol) return false;
      if (a.cost < b.cost - tol) return true;
      if (b.cost < a.cost - tol) return false;
      return a.duration <= b.duration + tol;
    }
    function replayRuns(patient, rules, actions) {
      // enumerate feasible runs that follow the action names
      const idx = new Map();
      for (const r of rules) {
        const k = r.from_state + "@" + r.action;
        if (!idx.has(k)) idx.set(k, []);
        idx.get(k).push(r);
      }
      const runs = [];
      function dfs(i, cur, dur, cost, succ, comf) {
        if (i === actions.length) {
          runs.push({end:cur, dur, cost, succ, comf});
          return;
        }
        const a = actions[i];
        for (const r of (idx.get(cur + "@" + a) || [])) {
          if (!r.applies(patient, cur)) continue;
          const nd = dur + r.duration_d;
          const nc = cost + r.cost;
          const ns = succ * r.success_p;
          const nf = comf * r.comfort_p;
          if (!(nd <= MAX_DURATION_D && nc <= MAX_COST && ns >= MIN_SUCCESS_P && nf >= MIN_COMFORT_P)) continue;
          dfs(i+1, r.to_state, nd, nc, ns, nf);
        }
      }
      dfs(0, patient.state, 0, 0.0, 1.0, 1.0);
      return runs;
    }
    function harness(patient, rules, solutions) {
      if (!solutions.length) return "No solutions — nothing to verify.";

      // 1) uniqueness of action lists
      const paths = solutions.map(n => JSON.stringify(n.path));
      if (new Set(paths).size !== paths.length) throw new Error("Duplicate action lists found.");

      // 2) goal, limits, length
      for (const n of solutions) {
        if (n.state !== GOAL_STATE) throw new Error("Wrong end state for " + JSON.stringify(n.path));
        if (n.path.length > MAX_STAGECOUNT) throw new Error("Path too long: " + JSON.stringify(n.path));
        if (!(n.duration <= MAX_DURATION_D && n.cost <= MAX_COST && n.succ >= MIN_SUCCESS_P && n.comfort >= MIN_COMFORT_P)) {
          throw new Error("Global limits violated by " + JSON.stringify(n.path));
        }
      }

      // 3) replay totals
      for (const n of solutions) {
        const runs = replayRuns(patient, rules, n.path);
        if (!runs.length) throw new Error("No feasible run for actions " + JSON.stringify(n.path));
        let matched = false;
        for (const r of runs) {
          if (r.end === n.state && approx(r.dur, n.duration) && approx(r.cost, n.cost, 1e-9) && approx(r.succ, n.succ) && approx(r.comf, n.comfort)) {
            matched = true; break;
          }
        }
        if (!matched) throw new Error("Recorded totals do not match any feasible replay for " + JSON.stringify(n.path));
      }

      // 4) sorted by key
      for (let i=0; i+1<solutions.length; i++) {
        if (!leqByKey(solutions[i], solutions[i+1])) {
          throw new Error("Solutions not sorted by (success↓, cost↑, duration↑).");
        }
      }

      // 5) first is optimal
      const best = solutions[0];
      for (const n of solutions.slice(1)) {
        if (!leqByKey(best, n)) throw new Error("First solution is not optimal under the specified ordering.");
      }
      return `Harness: ${solutions.length} solutions verified — uniqueness, constraints, replay totals, and ordering. ✓`;
    }

    function runWith(n3) {
      const rules = parseRules(n3);
      const solutions = searchAll(PATIENT, rules);
      setHTML("answer", renderSolutions(solutions));
      setHTML("reason", renderReason(PATIENT, rules));
      try {
        sortSolutions(solutions);
        const msg = harness(PATIENT, rules, solutions);
        setHTML("check", `<p class="ok mono">${msg}</p>`);
      } catch (e) {
        setHTML("check", `<p class="bad mono">Harness failed: ${e.message || e}</p>`);
      }
    }

    $("run").addEventListener("click", () => runWith(DEMO_N3));
    $("use-embedded").addEventListener("click", () => runWith($("rulesbox").value));

    // Auto-run demo once on load
    runWith(DEMO_N3);
  })();
  </script>
</body>
</html>

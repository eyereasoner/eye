<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GPS Clinical Bench (1000) — web version</title>
  <style>
    :root { --fg:#101014; --bg:#ffffff; --muted:#666; --accent:#2563eb; --chip:#eef2ff; }
    @media (prefers-color-scheme: dark) {
      :root { --fg:#eaeaf0; --bg:#0b0b10; --muted:#a0a0b0; --accent:#60a5fa; --chip:#0e1a32; }
    }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font: 15px/1.6 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    main { max-width: 1000px; margin: 0 auto; padding: 28px 16px 80px; }
    h1 { font-size: clamp(1.6rem, 2.6vw + 1rem, 2.2rem); margin: 0 0 6px; }
    header p { margin: 0; color: var(--muted); }
    section { margin: 18px 0 22px; padding: 14px 14px 16px; border: 1px solid color-mix(in srgb, var(--accent) 18%, transparent); border-radius: 14px;
              background: color-mix(in srgb, var(--accent) 4%, transparent); }
    section h2 { margin: 0 0 8px; font-size: 1.15rem; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:10px; }
    .chip { display:inline-block; padding:2px 8px; border-radius:999px; background:var(--chip); font-weight:600; }
    .muted { color: var(--muted); }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .btn { appearance:none; border:1px solid color-mix(in srgb, var(--accent) 35%, transparent); background: color-mix(in srgb, var(--accent) 8%, transparent);
           color: var(--fg); border-radius: 10px; padding: 8px 12px; font-weight: 700; cursor: pointer; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .tbl { width:100%; border-collapse: collapse; }
    .tbl th, .tbl td { padding: 6px 8px; border-bottom: 1px dashed color-mix(in srgb, var(--fg) 18%, transparent); vertical-align: top; }
    .tbl th { text-align:left; }
    details { border-radius: 10px; padding: 10px 12px; background: color-mix(in srgb, var(--accent) 6%, transparent); }
    summary { cursor:pointer; font-weight:700; }
    .ok { color: #16a34a; }
    .warn { color: #ca8a04; }
    .bad { color: #dc2626; }
    .small { font-size: 0.92em; }
    code { background: color-mix(in srgb, var(--accent) 10%, transparent); padding: .1rem .35rem; border-radius: .35rem; }
  </style>
</head>
<body>
  <main>
    <header class="row">
      <div>
        <h1>GPS Clinical Bench — 1000 rules</h1>
        <p>Web-only port that fetches the rules, runs the search in your browser, and renders the results.</p>
      </div>
      <div style="margin-left:auto">
        <button id="run" class="btn">Run</button>
      </div>
    </header>

    <section>
      <div class="grid">
        <div>Goal state: <span class="chip mono" id="goal">state_6</span></div>
        <div>Limits: <span class="chip mono">duration ≤ 180d</span> <span class="chip mono">cost ≤ €500</span> <span class="chip mono">success ≥ 0.35</span> <span class="chip mono">comfort ≥ 0.35</span> <span class="chip mono">stagecount ≤ 10</span></div>
      </div>
      <p class="muted small" id="src">Source: <a href="https://raw.githubusercontent.com/eyereasoner/eye/refs/heads/master/librath/cases/gps_clinical_bench_1000.py" target="_blank" rel="noopener">rules &amp; patient definition</a></p>
    </section>

    <section>
      <h2>Patient</h2>
      <div id="patient" class="grid"></div>
    </section>

    <section>
      <h2>Answer</h2>
      <div id="answer"><em class="muted">Not computed yet.</em></div>
    </section>

    <section>
      <h2>Reason why</h2>
      <div id="reason"><em class="muted">Not computed yet.</em></div>
    </section>

    <section>
      <h2>Check (harness)</h2>
      <div id="check"><em class="muted">Not computed yet.</em></div>
    </section>
  </main>

  <script>
  (function(){
    const GOAL_STATE = "state_6";
    const MAX_DURATION_D = 180;
    const MAX_COST = 500.0;
    const MIN_SUCCESS_P = 0.35;
    const MIN_COMFORT_P = 0.35;
    const MAX_STAGECOUNT = 10;

    const RAW_URL = "https://raw.githubusercontent.com/eyereasoner/eye/refs/heads/master/librath/cases/gps_clinical_bench_1000.py";

    const $ = (id) => document.getElementById(id);
    const setHTML = (id, html) => { const el = $(id); if (el) el.innerHTML = html; };

    // ——————————————————————————————————————————————
    // Utilities
    // ——————————————————————————————————————————————
    const fmt = {
      euros: (x) => "€" + x.toFixed(2),
      prob: (x) => x.toFixed(3),
      days: (d) => d + (d === 1 ? " day" : " days"),
    };

    const cstr = (state, pathArr) => JSON.stringify([state, pathArr]); // key for visited

    // ——————————————————————————————————————————————
    // Parse helpers for the raw source
    // ——————————————————————————————————————————————
    function extractPatient(src) {
      // Very tolerant parse of patient_1 = Patient(...)
      const blockRe = /patient_1\s*=\s*Patient\s*\(([\s\S]*?)\)/m;
      const m = src.match(blockRe);
      if (!m) return null;
      const block = m[1];
      function pick(re, def=null) {
        const mm = block.match(re);
        return mm ? mm[1] : def;
      }
      const name = pick(/name\s*=\s*"([^"]+)"/);
      const gender = pick(/gender\s*=\s*"(Male|Female)"/);
      const age = +(pick(/age\s*=\s*(\d+)/) || 0);
      const state = pick(/state\s*=\s*"?(state_\d+)"?/);
      const uri = pick(/uri\s*=\s*"([^"]+)"/, "data:patient_1");
      const diagnosis = pick(/diagnosis\s*=\s*"([^"]+)"/, "");
      return { uri, name, gender, age, diagnosis, state };
    }

    function extractN3(src) {
      const re = /N3_RULES\s*=\s*textwrap\.dedent\(\s*"""([\s\S]*?)"""\)\.strip\(\)/m;
      const m = src.match(re);
      if (!m) throw new Error("Could not find N3_RULES triple-quoted block.");
      return m[1];
    }

    function parseRules(n3) {
      const rules = [];
      const ruleRe = new RegExp(
        String.raw`\{\s*care:Parkinson\s+gps:description\s+\(\s*`
        + String.raw`\{\?patient\s+care:state\s+care:(state_\d+)\.\}\s*` // from
        + String.raw`\{\?patient\s+gps:medication\s+medication:(Medication_\d+)\.\}\s*`
        + String.raw`\{\?patient\s+care:state\s+care:(state_\d+)\.\}\s*` // to
        + String.raw`action:([A-Za-z0-9_]+)\s*`
        + String.raw`"P(\d+)D"\^\^xsd:dayTimeDuration\s*`
        + String.raw`(\d+)\s*`      // cost (integer in source)
        + String.raw`([0-9.]+)\s*`  // success
        + String.raw`([0-9.]+)\s*`  // comfort
        + String.raw`\)\s*\}\s*<=\s*\{\s*`
        + String.raw`([\s\S]*?)\}\s*\.\s*`
      , "gs");

      const genderRe = /care:gender\s+care:(Male|Female)/;
      const minAgeRe = /math:greaterThan\s+(\d+)/;

      for (const m of n3.matchAll(ruleRe)) {
        const from_state = m[1];
        const /*medication*/ _med = m[2];
        const to_state = m[3];
        const action = m[4];
        const duration_d = parseInt(m[5], 10);
        const cost = parseFloat(m[6]);
        const success_p = parseFloat(m[7]);
        const comfort_p = parseFloat(m[8]);
        const body = m[9];

        let gender = null, minAge = null;
        const g = body.match(genderRe);
        if (g) gender = g[1];
        const a = body.match(minAgeRe);
        if (a) minAge = parseInt(a[1], 10);

        rules.push({
          from_state, to_state, action, duration_d, cost, success_p, comfort_p,
          applies(patient, cur_state) {
            const okGender = (gender === null) || (patient.gender === gender);
            const okAge = (minAge === null) || (patient.age > minAge);
            return cur_state === from_state && okGender && okAge;
          }
        });
      }
      return rules;
    }

    // ——————————————————————————————————————————————
    // Search (BFS, loop-free, same constraints)
    // ——————————————————————————————————————————————
    function searchAll(patient, rules) {
      const start = { state: patient.state, duration: 0, cost: 0.0, succ: 1.0, comfort: 1.0, path: [] };
      const queue = [start];
      const sols = [];
      const visited = new Set(); // key is [state, path]

      while (queue.length) {
        const cur = queue.shift();

        if (cur.state === GOAL_STATE) {
          sols.push(cur);
          // do not expand beyond a solution (like the source)
          continue;
        }
        if (cur.path.length >= MAX_STAGECOUNT) continue;

        for (const r of rules) {
          if (!r.applies(patient, cur.state)) continue;
          const nd = cur.duration + r.duration_d;
          const nc = cur.cost + r.cost;
          const ns = cur.succ * r.success_p;
          const nf = cur.comfort * r.comfort_p;
          if (!(nd <= MAX_DURATION_D && nc <= MAX_COST && ns >= MIN_SUCCESS_P && nf >= MIN_COMFORT_P)) continue;

          const nxtPath = cur.path.concat([r.action]);
          const sig = cstr(r.to_state, nxtPath);
          if (visited.has(sig)) continue;
          visited.add(sig);

          queue.push({ state: r.to_state, duration: nd, cost: nc, succ: ns, comfort: nf, path: nxtPath });
        }
      }
      return sols;
    }

    // ——————————————————————————————————————————————
    // Pretty printing & harness
    // ——————————————————————————————————————————————
    function sortSolutions(sols) {
      sols.sort((a,b) => {
        if (a.succ !== b.succ) return b.succ - a.succ; // higher first
        if (a.cost !== b.cost) return a.cost - b.cost;  // lower first
        return a.duration - b.duration;                 // shorter first
      });
    }

    function renderSolutions(solutions) {
      if (!solutions.length) {
        return `<p class="bad">⛔ No path satisfies the limits.</p>`;
      }
      sortSolutions(solutions);

      let html = `<p class="ok">✅ Found ${solutions.length} solution path(s):</p>`;
      html += `<table class="tbl mono small"><thead><tr>
        <th>#</th><th>steps</th><th>duration</th><th>cost</th><th>success</th><th>comfort</th><th>actions</th><th>end</th>
      </tr></thead><tbody>`;
      solutions.forEach((n, i) => {
        html += `<tr>
          <td>${i+1}</td>
          <td>${n.path.length} (≤ ${MAX_STAGECOUNT})</td>
          <td>${n.duration} (≤ ${MAX_DURATION_D})</td>
          <td>${fmt.euros(n.cost)} (≤ ${fmt.euros(MAX_COST)})</td>
          <td>${fmt.prob(n.succ)} (≥ ${MIN_SUCCESS_P})</td>
          <td>${fmt.prob(n.comfort)} (≥ ${MIN_COMFORT_P})</td>
          <td>${n.path.map((a,j)=>`${j+1}. ${a}`).join("<br>")}</td>
          <td>${n.state}</td>
        </tr>`;
      });
      html += `</tbody></table>`;

      const best = solutions[0];
      html += `<p class="small">Optimal by (succ↓, cost↑, dur↑): path = <code>${best.path.join(", ")}</code>,
               succ=${fmt.prob(best.succ)}, cost=${fmt.euros(best.cost)}, dur=${best.duration}d</p>`;
      return html;
    }

    function applicableFromState(patient, rules, state) {
      return rules.filter(r => r.applies(patient, state));
    }

    function renderReason(patient, rules) {
      const apps = applicableFromState(patient, rules, patient.state);
      if (!apps.length) {
        return `<p>From the start state <code>${patient.state}</code>, applicable rules: 0 — start is a dead-end for these demographics.</p>`;
      }
      let html = `<p>From the start state <code>${patient.state}</code>, applicable rules for this patient: ${apps.length}</p>`;
      const oneStep = apps.filter(r => r.to_state === GOAL_STATE);
      if (oneStep.length) {
        html += `<p><strong>One-step routes to the goal:</strong></p><ul class="mono small">`;
        oneStep.forEach(r => {
          html += `<li>${r.action}: ${r.from_state} → ${r.to_state} (+${r.duration_d}d, +€${r.cost.toFixed(0)}, ×succ ${r.success_p.toFixed(3)}, ×comf ${r.comfort_p.toFixed(3)})</li>`;
        });
        html += `</ul>`;
      } else {
        html += `<p>No single step reaches the goal.</p>`;
      }
      const others = apps.filter(r => r.to_state !== GOAL_STATE).slice(0, 20);
      if (others.length) {
        html += `<p><strong>Sample of other applicable first steps (max 20 shown):</strong></p><ul class="mono small">`;
        others.forEach(r => {
          html += `<li>${r.action}: ${r.from_state} → ${r.to_state} (+${r.duration_d}d, +€${r.cost.toFixed(0)}, ×succ ${r.success_p.toFixed(3)}, ×comf ${r.comfort_p.toFixed(3)})</li>`;
        });
        html += `</ul>`;
      }
      return html;
    }

    // Harness checks mirroring the source
    function approx(a, b, tol=1e-12) {
      const d = Math.abs(a - b);
      return d <= tol * Math.max(1.0, 1.0 + Math.abs(a) + Math.abs(b));
    }
    function leqByKey(a, b, tol=1e-12) {
      if (a.succ > b.succ + tol) return true;
      if (b.succ > a.succ + tol) return false;
      if (a.cost < b.cost - tol) return true;
      if (b.cost < a.cost - tol) return false;
      return a.duration <= b.duration + tol;
    }
    function replayTotals(patient, rules, actions) {
      // build index by (from_state, action)
      const idx = new Map();
      for (const r of rules) {
        const k = r.from_state + "@" + r.action;
        if (!idx.has(k)) idx.set(k, []);
        idx.get(k).push(r);
      }
      let cur = patient.state, dur=0, cost=0, succ=1, comf=1;
      for (const a of actions) {
        const cand = (idx.get(cur + "@" + a) || []).filter(rr => rr.applies(patient, cur));
        if (!cand.length) throw new Error("Action not applicable from state " + cur);
        const r = cand[0];
        cur = r.to_state;
        dur += r.duration_d; cost += r.cost; succ *= r.success_p; comf *= r.comfort_p;
      }
      return {dur, cost, succ, comf, end: cur};
    }
    function replayRuns(patient, rules, actions) {
      // enumerate all feasible runs that follow the action names
      const idx = new Map();
      for (const r of rules) {
        const k = r.from_state + "@" + r.action;
        if (!idx.has(k)) idx.set(k, []);
        idx.get(k).push(r);
      }
      const runs = [];
      function dfs(i, cur, dur, cost, succ, comf) {
        if (i === actions.length) {
          runs.push({end:cur, dur, cost, succ, comf});
          return;
        }
        const a = actions[i];
        for (const r of (idx.get(cur + "@" + a) || [])) {
          if (!r.applies(patient, cur)) continue;
          const nd = dur + r.duration_d;
          const nc = cost + r.cost;
          const ns = succ * r.success_p;
          const nf = comf * r.comfort_p;
          if (!(nd <= MAX_DURATION_D && nc <= MAX_COST && ns >= MIN_SUCCESS_P && nf >= MIN_COMFORT_P)) continue;
          dfs(i+1, r.to_state, nd, nc, ns, nf);
        }
      }
      dfs(0, patient.state, 0, 0.0, 1.0, 1.0);
      return runs;
    }
    function harness(patient, rules, solutions) {
      if (!solutions.length) return "No solutions — nothing to verify.";

      // 1) uniqueness of action lists
      const paths = solutions.map(n => JSON.stringify(n.path));
      if (new Set(paths).size !== paths.length) throw new Error("Duplicate action lists found.");

      // 2) goal, limits, length
      for (const n of solutions) {
        if (n.state !== GOAL_STATE) throw new Error("Wrong end state for " + JSON.stringify(n.path));
        if (n.path.length > MAX_STAGECOUNT) throw new Error("Path too long: " + JSON.stringify(n.path));
        if (!(n.duration <= MAX_DURATION_D && n.cost <= MAX_COST && n.succ >= MIN_SUCCESS_P && n.comfort >= MIN_COMFORT_P)) {
          throw new Error("Global limits violated by " + JSON.stringify(n.path));
        }
      }

      // 3) replay totals
      for (const n of solutions) {
        const runs = replayRuns(patient, rules, n.path);
        if (!runs.length) throw new Error("No feasible run for actions " + JSON.stringify(n.path));
        let matched = false;
        for (const r of runs) {
          if (r.end === n.state && approx(r.dur, n.duration) && approx(r.cost, n.cost, 1e-9) && approx(r.succ, n.succ) && approx(r.comf, n.comfort)) {
            matched = true; break;
          }
        }
        if (!matched) throw new Error("Recorded totals do not match any feasible replay for " + JSON.stringify(n.path));
      }

      // 4) sorted by key
      for (let i=0; i+1<solutions.length; i++) {
        if (!leqByKey(solutions[i], solutions[i+1])) {
          throw new Error("Solutions not sorted by (success↓, cost↑, duration↑).");
        }
      }

      // 5) first is optimal
      const best = solutions[0];
      for (const n of solutions.slice(1)) {
        if (!leqByKey(best, n)) throw new Error("First solution is not optimal under the specified ordering.");
      }
      return `Harness: ${solutions.length} solutions verified — uniqueness, constraints, replay totals, and ordering. ✓`;
    }

    async function run() {
      const btn = $("run");
      btn.disabled = true;
      btn.textContent = "Running…";

      try {
        const res = await fetch(RAW_URL, { cache:"no-store" });
        if (!res.ok) throw new Error("Fetch failed: " + res.status);
        const src = await res.text();

        const patient = extractPatient(src);
        if (!patient) throw new Error("Could not parse patient from source.");

        // Show patient
        setHTML("patient", `<div>Name: <span class="chip">${patient.name}</span></div>
          <div>Gender: <span class="chip">${patient.gender}</span></div>
          <div>Age: <span class="chip">${patient.age}</span></div>
          <div>Start state: <span class="chip mono">${patient.state}</span></div>`);

        const n3 = extractN3(src);
        const rules = parseRules(n3);

        // Run search
        const solutions = searchAll(patient, rules);

        // Render sections
        setHTML("answer", renderSolutions(solutions));
        setHTML("reason", renderReason(patient, rules));
        let checkMsg;
        try {
          // Verify after sorting, like the source does before reading best
          sortSolutions(solutions);
          checkMsg = harness(patient, rules, solutions);
          setHTML("check", `<p class="ok mono">${checkMsg}</p>`);
        } catch (e) {
          setHTML("check", `<p class="bad mono">Harness failed: ${e.message || e}</p>`);
        }
      } catch (e) {
        setHTML("answer", `<p class="bad">Error: ${e.message || e}</p>`);
      } finally {
        btn.disabled = false;
        btn.textContent = "Run again";
      }
    }

    $("run").addEventListener("click", run);
    // Auto-run once for convenience
    run();
  })();
  </script>
</body>
</html>

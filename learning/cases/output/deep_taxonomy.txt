dt_result = ('i', 'n100000')

Answer
======
Seed facts |element_of| = 1
Taxonomy edges |subclass_of| = 400000
Inferred facts |pairs| = 400001  (unique classes reached = 400001)

Deepest chain on the ‘n’ lineage:
  dt_result = ('i', 'n100000')  → deepest n = n100000

By lineage (instance ‘i’):
  n* classes reached: 100001
  i* classes reached: 100000
  j* classes reached: 100000
  k* classes reached: 100000

Reason why
==========
We perform a forward reachability over the subclass-of DAG/graph:
  • Build parent adjacency: for each class C, parents(C) = {superclasses of C}.
  • Seed a work-list with the given (instance, class) facts.
  • Pop (i, C); for each S ∈ parents(C) that hasn’t been seen, add (i, S) and push it.
Because each derived pair is enqueued at most once, and each taxonomy edge is
examined only when its child class is popped, the algorithm runs in O(E+F) time
and O(V+F) memory (dedup sets ensure termination even with cycles).

Check (harness)
===============
Deepest n in demo equals n100000? True  (got n100000)
Seeds included in closure? True
Idempotence and cycle tolerance on toy taxonomy? True
Monotonicity (add edge C→D adds (x,D))? True
Deterministic on demo inputs (size & key fact stable)? True

All checks passed? True

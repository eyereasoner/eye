Answer
------
Residual program (generated at mix time):
def even_res(n: int) -> bool:
    """Residual: decide even(s^n(0)) for n ≥ 0 (specialized to the fixed Horn program)."""
    if n < 0:
        raise ValueError('n must be ≥ 0 (represents s^n(0))')
    # From clause (2): each s(s(_)) layer lets us subtract 2 from n
    while n >= 2:
        n -= 2
    # From clause (1): even(0). All other one-layer remainder is odd.
    return n == 0
Example evaluation: for n = 13 (i.e., t = s^13(0)), even_res(n) = False

Reason why
----------
• Signature Σ: constants {0}, function {s/1}, predicate {even/1}.
• Herbrand universe: {0, s(0), s(s(0)), ...}.
• Program clauses: (1) even(0).  (2) even(s(s(X))) :- even(X).
• Observation: the only recursive clause strips TWO s-layers.
• ⇒ For a ground term t = s^n(0), even(t) depends only on n mod 2.
• We encode terms by their s-depth n (non-negative integers).
• At mix time we replace unification with n-=2 steps and the base test n==0.
• Example unfolding for n = 13: n path [13, 11, 9, 7, 5, 3, 1] → return (n==0) = False.

Check (harness)
----------------
PASS: residual even_res matches the generic Herbrand evaluator on 608 inputs (including large n).


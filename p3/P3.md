# P3: Prompt â†’ Program â†’ Proof

## A Framework for Verifiable, Explainable, and Auditable AI

In an era of powerful AI, translating raw **data** into trusted, actionable insight remains a major hurdle. How can we be sure an LLM's answer is correct? How can we audit its reasoning? How can we automate this process with confidence?

P3 is a method that addresses this challenge by teaching a Large Language Model (LLM) to perform a specific, rigorous task. It transforms raw inputsâ€”**Data**, **Logic**, and a **Goal**â€”into a single, **self-contained Python program**. This program is fully autonomous and, most importantly, is required to deliver a "triad of trust":

1.  The final **Answer**.
2.  A clear explanation of the **Reason Why**.
3.  An independent **Check** that validates the result, guarding against errors and hallucinations.

> ðŸ’¡ In P3, **Proof** = **Reason Why** + **Check**. The program must both explain its conclusion *and* verify it.

A [public repository](https://github.com/eyereasoner/eye/tree/master/p3) provides more than 200 cases and a one-command `./test` runner to reproduce this "answer, reason, check" triad for every case.

---

## P3 in a Nutshell: Goal-directed Program Synthesis (quite like a GPS)

At its core, P3 is a pattern for **goal-directed program synthesis**. Think of it as giving a brilliant but literal programmer a complete lesson plan. You provide the task, all necessary materials, and a precise specification for the deliverable.

The process is straightforward:

1.  **Formulate a Prompt** that instructs the LLM on what kind of program to write.
2.  **Declare a precise Goal** within that prompt (e.g., "Is this transaction compliant?" or "Find all ancestors of person X.").
3.  **Provide the necessary Data** (the facts) and the **Logic** (the rules) that govern the domain.
4.  **Instruct the LLM** to write a **self-contained Python program** that ingests these inputs and produces the complete "answer, reason, check" output.

The final deliverable isn't just a code snippet; it's a **trustworthy and auditable artifact** you can execute in a CI/CD pipeline, share with auditors, and deploy with confidence.

---

## Key Advantages: A Hybrid Approach

P3 stands out by blending the flexibility of generative AI with the rigor of symbolic systems.

* **Verifiable by Design:** Every output is a self-contained Python program with its own built-in test harness (the **Check**). Each execution produces both a result (**Answer**) and an independent verification, moving beyond the "black box" paradigm.
* **A Bridge Between Symbolic and Generative AI:** P3 uses the LLM for what it does bestâ€”understanding intent and synthesizing code structureâ€”while relying on formal **Logic** to ensure the reasoning is explicit and explainable (**Reason Why**).
* **Explainable by Default:** The generated program is explicitly required to explain its reasoning. You don't just know *what* the answer is; you know *why* it's the answer and have the means to prove it.
* **Durable, Goal-First Assets:** By starting with a precise **Goal**, the LLM creates a concrete, repeatable procedure. The resulting program becomes a durable asset, perfect for automation, compliance, and reproducible research.

---

## Architecture at a Glance

The conceptual pipeline is simple. The inputs (**Data**, **Logic**, and **Goal**) are fed into an LLM, which acts as a synthesizer. Its sole job is to produce one artifact: the final, executable program that generates the **Answer**, **Reason Why**, and **Check**.

<svg width="278pt" height="260pt" viewBox="0.00 0.00 278.00 260.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)">
<title>%3</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-256 274,-256 274,4 -4,4"/>
<!-- Data -->
<g id="node1" class="node">
<title>Data</title>
<path fill="yellow" stroke="navy" d="M82,-252C82,-252 52,-252 52,-252 46,-252 40,-246 40,-240 40,-240 40,-228 40,-228 40,-222 46,-216 52,-216 52,-216 82,-216 82,-216 88,-216 94,-222 94,-228 94,-228 94,-240 94,-240 94,-246 88,-252 82,-252"/>
<text text-anchor="middle" x="67" y="-230.3" font-family="Times,serif" font-size="14.00">Data</text>
</g>
<!-- LLM -->
<g id="node4" class="node">
<title>LLM</title>
<path fill="yellow" stroke="navy" d="M234.5,-180C234.5,-180 45.5,-180 45.5,-180 39.5,-180 33.5,-174 33.5,-168 33.5,-168 33.5,-156 33.5,-156 33.5,-150 39.5,-144 45.5,-144 45.5,-144 234.5,-144 234.5,-144 240.5,-144 246.5,-150 246.5,-156 246.5,-156 246.5,-168 246.5,-168 246.5,-174 240.5,-180 234.5,-180"/>
<text text-anchor="middle" x="140" y="-158.3" font-family="Times,serif" font-size="14.00">LLM&#45;based Code Generator</text>
</g>
<!-- Data&#45;&gt;LLM -->
<g id="edge4" class="edge">
<title>Data&#45;&gt;LLM</title>
<path fill="none" stroke="black" d="M85.04,-215.7C94.06,-207.05 105.12,-196.45 114.94,-187.03"/>
<polygon fill="black" stroke="black" points="117.37,-189.55 122.16,-180.1 112.52,-184.5 117.37,-189.55"/>
</g>
<!-- Logic -->
<g id="node2" class="node">
<title>Logic</title>
<path fill="yellow" stroke="navy" d="M155.5,-252C155.5,-252 124.5,-252 124.5,-252 118.5,-252 112.5,-246 112.5,-240 112.5,-240 112.5,-228 112.5,-228 112.5,-222 118.5,-216 124.5,-216 124.5,-216 155.5,-216 155.5,-216 161.5,-216 167.5,-222 167.5,-228 167.5,-228 167.5,-240 167.5,-240 167.5,-246 161.5,-252 155.5,-252"/>
<text text-anchor="middle" x="140" y="-230.3" font-family="Times,serif" font-size="14.00">Logic</text>
</g>
<!-- Logic&#45;&gt;LLM -->
<g id="edge5" class="edge">
<title>Logic&#45;&gt;LLM</title>
<path fill="none" stroke="black" d="M140,-215.7C140,-207.98 140,-198.71 140,-190.11"/>
<polygon fill="black" stroke="black" points="143.5,-190.1 140,-180.1 136.5,-190.1 143.5,-190.1"/>
</g>
<!-- Goal -->
<g id="node3" class="node">
<title>Goal</title>
<path fill="yellow" stroke="navy" d="M228,-252C228,-252 198,-252 198,-252 192,-252 186,-246 186,-240 186,-240 186,-228 186,-228 186,-222 192,-216 198,-216 198,-216 228,-216 228,-216 234,-216 240,-222 240,-228 240,-228 240,-240 240,-240 240,-246 234,-252 228,-252"/>
<text text-anchor="middle" x="213" y="-230.3" font-family="Times,serif" font-size="14.00">Goal</text>
</g>
<!-- Goal&#45;&gt;LLM -->
<g id="edge6" class="edge">
<title>Goal&#45;&gt;LLM</title>
<path fill="none" stroke="black" d="M194.96,-215.7C185.94,-207.05 174.88,-196.45 165.06,-187.03"/>
<polygon fill="black" stroke="black" points="167.48,-184.5 157.84,-180.1 162.63,-189.55 167.48,-184.5"/>
</g>
<!-- Python -->
<g id="node5" class="node">
<title>Python</title>
<path fill="yellow" stroke="navy" d="M247.5,-108C247.5,-108 32.5,-108 32.5,-108 26.5,-108 20.5,-102 20.5,-96 20.5,-96 20.5,-84 20.5,-84 20.5,-78 26.5,-72 32.5,-72 32.5,-72 247.5,-72 247.5,-72 253.5,-72 259.5,-78 259.5,-84 259.5,-84 259.5,-96 259.5,-96 259.5,-102 253.5,-108 247.5,-108"/>
<text text-anchor="middle" x="140" y="-86.3" font-family="Times,serif" font-size="14.00">Self&#45;contained Python Program</text>
</g>
<!-- LLM&#45;&gt;Python -->
<g id="edge7" class="edge">
<title>LLM&#45;&gt;Python</title>
<path fill="none" stroke="black" d="M140,-143.7C140,-135.98 140,-126.71 140,-118.11"/>
<polygon fill="black" stroke="black" points="143.5,-118.1 140,-108.1 136.5,-118.1 143.5,-118.1"/>
</g>
<!-- Answer -->
<g id="node6" class="node">
<title>Answer</title>
<path fill="yellow" stroke="navy" d="M58,-36C58,-36 12,-36 12,-36 6,-36 0,-30 0,-24 0,-24 0,-12 0,-12 0,-6 6,0 12,0 12,0 58,0 58,0 64,0 70,-6 70,-12 70,-12 70,-24 70,-24 70,-30 64,-36 58,-36"/>
<text text-anchor="middle" x="35" y="-14.3" font-family="Times,serif" font-size="14.00">Answer</text>
</g>
<!-- Python&#45;&gt;Answer -->
<g id="edge1" class="edge">
<title>Python&#45;&gt;Answer</title>
<path fill="none" stroke="black" d="M114.31,-71.88C100.71,-62.81 83.83,-51.55 69.14,-41.76"/>
<polygon fill="black" stroke="black" points="71.05,-38.82 60.78,-36.19 67.16,-44.65 71.05,-38.82"/>
</g>
<!-- Reason -->
<g id="node7" class="node">
<title>Reason</title>
<path fill="yellow" stroke="navy" d="M180,-36C180,-36 100,-36 100,-36 94,-36 88,-30 88,-24 88,-24 88,-12 88,-12 88,-6 94,0 100,0 100,0 180,0 180,0 186,0 192,-6 192,-12 192,-12 192,-24 192,-24 192,-30 186,-36 180,-36"/>
<text text-anchor="middle" x="140" y="-14.3" font-family="Times,serif" font-size="14.00">Reason Why</text>
</g>
<!-- Python&#45;&gt;Reason -->
<g id="edge2" class="edge">
<title>Python&#45;&gt;Reason</title>
<path fill="none" stroke="black" d="M140,-71.7C140,-63.98 140,-54.71 140,-46.11"/>
<polygon fill="black" stroke="black" points="143.5,-46.1 140,-36.1 136.5,-46.1 143.5,-46.1"/>
</g>
<!-- Check -->
<g id="node8" class="node">
<title>Check</title>
<path fill="yellow" stroke="navy" d="M258,-36C258,-36 222,-36 222,-36 216,-36 210,-30 210,-24 210,-24 210,-12 210,-12 210,-6 216,0 222,0 222,0 258,0 258,0 264,0 270,-6 270,-12 270,-12 270,-24 270,-24 270,-30 264,-36 258,-36"/>
<text text-anchor="middle" x="240" y="-14.3" font-family="Times,serif" font-size="14.00">Check</text>
</g>
<!-- Python&#45;&gt;Check -->
<g id="edge3" class="edge">
<title>Python&#45;&gt;Check</title>
<path fill="none" stroke="black" d="M164.46,-71.88C177.3,-62.89 193.2,-51.76 207.09,-42.03"/>
<polygon fill="black" stroke="black" points="209.26,-44.79 215.44,-36.19 205.24,-39.06 209.26,-44.79"/>
</g>
</g>
</svg>

This architecture is built on two principles: (1) runtime **verification is mandatory**, and (2) the primary output is a **portable program** that is easy to manage, version, and execute anywhere.

---

## Advanced Pattern: High-Performance Mixed Computation

For performance-critical applications, P3 supports an advanced **"mixed computation"** pattern, inspired by foundational computer science principles[^mc]. This approach teaches the LLM to separate stable **Logic** from dynamic **Data**.

The LLM-guided synthesis acts as a "specializer," converting declarative **Logic** into a compact, highly efficient Python **Driver** function.

* **Speed:** At runtime, this specialized Driver is extremely fast. It consumes only dynamic facts (e.g., a new user transaction) and applies the pre-compiled logic to emit the standard "answer, reason, check" triad.
* **Governance:** The core logic remains in a human-readable format. To update a policy, you simply update the logic and re-run synthesis to generate a new Driverâ€”no complex algorithmic rewrite is needed.
* **Trust:** This approach preserves the core P3 contract while dramatically improving **speed, determinism, and auditability**. Your logic stays declarative, while your execution becomes small, fast, and predictable.

---

## Getting Started: The P3 Workflow

Adopting P3 is an iterative process:

1.  **Define Your Goal:** Start by clearly stating the decision, conclusion, or question you need to answer.
2.  **Assemble Your Inputs:** Gather the relevant **Data** files, the **Logic** that defines your operational rules, and a **Prompt** that explains the task to the LLM.
3.  **Synthesize the Program:** Use the prompt to guide the LLM in generating the **self-contained Python program**.
4.  **Execute and Validate:** Run the program. Confirm that the **Answer**, **Reason Why**, and **Check** are correct. The repository's `./test` command automates this.
5.  **Iterate and Harden:** As your data and logic evolve, simply refine your inputs and re-run the synthesis step to create an updated, validated artifact.

---

## Why P3 Matters: Practical Benefits

* **Builds Unprecedented Trust:** The "answer, reason, check" triad makes every output verifiable and explainable, which is essential for regulatory and compliance-driven environments.
* **Enables Extreme Automation:** By producing self-contained executables, P3 integrates seamlessly into modern DevOps and MLOps pipelines. Generated programs can be versioned in Git, tested in CI, and deployed anywhere.
* **Lowers Maintenance Overhead:** Policies are maintained as declarative logic, not complex code. To make a change, you update the logic and regenerate the program.
* **Democratizes Expertise:** Subject matter experts can define operational logic in a high-level format, while the LLM handles the complex task of translating it into efficient, verifiable code.

---

## Appendix

[^mc]: Ershov, A. P. (1982). *Mixed Computation: Potential Applications and Problems for Study*. Theoretical Computer Science, 18, 41â€“67.

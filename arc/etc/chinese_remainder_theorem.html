<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chinese Remainder Theorem</title>
<style>
  :root{
    --bg:#f9fafb; --card:#ffffff; --ink:#111827; --ink-dim:#4b5563;
    --muted:#6b7280; --border:#e5e7eb; --code:#f3f4f6;
    --accent:#2563eb; --accent-ink:#ffffff; --ok:#16a34a; --warn:#dc2626;
    --badge:#e2e8f0; --badge-ink:#334155;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial}
  .wrap{max-width:900px;margin:0 auto;padding:28px 16px 40px}
  header{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:16px}
  header h1{margin:0;font-size:20px;font-weight:700;letter-spacing:.2px}
  .badge{background:var(--badge);color:var(--badge-ink);border:1px solid var(--border);padding:6px 10px;border-radius:999px;font-size:12px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:18px;box-shadow:0 10px 30px rgba(0,0,0,.04);margin-top:16px}
  .card h2{margin:0 0 12px;font-size:16px;letter-spacing:.2px}
  .card h3{margin:16px 0 8px;font-size:14px;color:var(--ink-dim);font-weight:600}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .input{background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px 12px;color:var(--ink);font-weight:600}
  .input:focus{outline:3px solid rgba(37,99,235,.2);border-color:#93c5fd}
  .btn{background:var(--accent);color:var(--accent-ink);border:0;padding:10px 14px;font-weight:700;border-radius:12px;cursor:pointer}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .btn.secondary{background:#e5e7eb;color:#111827}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  .dim{color:var(--muted)}
  .kpi{font-weight:800}
  .stat{
    display:grid; grid-template-columns:auto 1fr; align-items:baseline; gap:8px;
    background:#fff; padding:8px 10px; border-radius:12px; border:1px solid var(--border);
  }
  #answer{
    max-width:100%; white-space:normal; overflow-wrap:anywhere; word-break:break-word; line-break:anywhere;
    font-size:clamp(0.9rem, 1vw + 0.75rem, 1.1rem);
  }
  table{width:100%; border-collapse:collapse}
  th, td{border:1px solid var(--border); padding:8px; text-align:left}
  th{background:#f3f4f6; font-weight:600; color:#374151}
  .log{font-size:13px;max-height:240px;overflow:auto;background:var(--code);border:1px dashed var(--border);padding:10px;border-radius:12px;white-space:pre-wrap}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--border);background:#fff;color:var(--ink-dim);font-size:12px}
  code,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
  pre{background:var(--code);border:1px solid var(--border);border-radius:12px;padding:14px;overflow:auto}
  .ok{color:var(--ok)} .bad{color:var(--warn)}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Chinese Remainder Theorem (CRT)</h1>
  </header>

  <!-- Mathematical English -->
  <section class="card">
    <h2>Chinese Remainder Theorem (statement)</h2>
    <p class="dim">
      Let <em>m₁,…,m<sub>r</sub></em> be pairwise coprime positive integers and let residues
      <em>a₁,…,a<sub>r</sub></em> be given. Then there exists a unique residue class
      <em>x</em> modulo <em>M = m₁···m<sub>r</sub></em> with
      <em>x ≡ aᵢ (mod mᵢ)</em> for every <em>i</em>. “Unique” means that any two solutions differ by a multiple of <em>M</em>.
    </p>
    <p class="dim">
      We will compute the representative <em>x ∈ {0,…,M−1}</em> using inverses (Answer), and independently
      <em>re-find</em> it by naive searching along arithmetic progressions (Check).
    </p>
  </section>

  <!-- A · Answer -->
  <section class="card">
    <h2>Answer</h2>
    <p class="dim">Enter congruences of the form <span class="mono">x ≡ aᵢ (mod mᵢ)</span>. The moduli must be pairwise coprime.</p>
    <div class="row" style="margin:10px 0">
      <button id="exBtn" class="btn secondary">Load example</button>
      <button id="addBtn" class="btn secondary">Add row</button>
      <button id="runBtn" class="btn">Compute + Check</button>
    </div>
    <table id="sys">
      <thead><tr><th>aᵢ (remainder)</th><th>mᵢ (modulus)</th><th>remove</th></tr></thead>
      <tbody></tbody>
    </table>

    <h3 style="margin-top:14px">Solution</h3>
    <div class="stat" role="status" aria-live="polite">
      <span class="dim">x ≡</span>
      <span id="answer" class="kpi mono">–</span>
    </div>
    <p class="dim">This is the unique solution modulo <span class="mono" id="modulus">M</span>.</p>
  </section>

  <!-- R · Reason why -->
  <section class="card">
    <h2>Reason why (Lean 4 sketch)</h2>
    <p class="dim">
      For coprime moduli, mathlib provides Chinese remainder isomorphisms.
      Conceptually, one builds idempotents using Bézout coefficients and glues the residues.
    </p>
<pre><code>-- Lean 4 (mathlib) sketch: CRT for pairwise coprime moduli
import Mathlib
open scoped BigOperators
open Finset

/-- Chinese Remainder Theorem (sketch):
    For pairwise-coprime mᵢ > 0 and residues aᵢ, there exists a unique x mod M = ∏ mᵢ
    with x ≡ aᵢ [ZMOD mᵢ] for all i. -/
theorem chineseRemainder_pairwise
  {ι : Type*} (m : ι → ℕ) (a : ι → ℤ)
  (hc : Pairwise (fun i j => i ≠ j → Nat.Coprime (m i) (m j)))
  (hpos : ∀ i, 0 < m i) :
  ∃! x : ℤ,
    ∀ i, x ≡ a i [ZMOD m i] := by
  -- Outline: use the ring isomorphism
  --   (ZMod (∏ i, m i)) ≃ Π i, ZMod (m i)
  -- available under pairwise coprimality, and map (a i mod m i) back.
  -- Uniqueness holds modulo M = ∏ m i.
  admit
</code></pre>
    <p class="dim">The snippet captures the formal reason; the browser doesn’t execute Lean.</p>
  </section>

  <!-- C · Check (independent harness) -->
  <section class="card">
    <h2>Check (independent harness)</h2>
    <p class="dim">
      Without using inverses or CRT, we re-construct the same solution by **naively searching**:
      start with the first congruence and scan the arithmetic progression to meet the second,
      then repeat (step size grows by the current modulus). This is guaranteed to find the solution
      when moduli are coprime; it’s independent from the Answer’s inverse-based construction.
    </p>

    <div class="row" style="margin-bottom:8px">
      <div id="statusPill" class="pill">idle</div>
      <div><span class="dim">progress:</span> <span id="progress" class="mono">0%</span></div>
    </div>
    <div id="log" class="log mono" aria-live="polite"></div>

    <h3>Result</h3>
    <p><span class="dim">Check status:</span> <strong id="checkStatus">–</strong></p>
  </section>
</div>

<script>
(function () {
  // --- UI elements ---
  const tbody   = document.querySelector('#sys tbody');
  const addBtn  = document.getElementById('addBtn');
  const exBtn   = document.getElementById('exBtn');
  const runBtn  = document.getElementById('runBtn');
  const answerEl= document.getElementById('answer');
  const modulusEl = document.getElementById('modulus');
  const logEl   = document.getElementById('log');
  const progEl  = document.getElementById('progress');
  const pillEl  = document.getElementById('statusPill');
  const checkEl = document.getElementById('checkStatus');

  // --- helpers ---
  function setStatus(text, kind) {
    pillEl.textContent = text;
    pillEl.style.borderColor = 'var(--border)';
    if (kind === 'ok') { pillEl.style.background = '#dcfce7'; pillEl.style.color = 'var(--ok)'; }
    else if (kind === 'bad') { pillEl.style.background = '#fee2e2'; pillEl.style.color = 'var(--warn)'; }
    else { pillEl.style.background = '#fff'; pillEl.style.color = 'var(--ink-dim)'; }
  }
  function log(line){ logEl.textContent += line + '\n'; logEl.scrollTop = logEl.scrollHeight; }
  function resetUI(){ logEl.textContent=''; progEl.textContent='0%'; checkEl.textContent='–'; checkEl.className=''; setStatus('idle'); }
  function fmt(x){ const s = x.toString(); return s.replace(/\B(?=(\d{3})+(?!\d))/g, ','); }

  function addRow(a='', m=''){
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input class="input mono" type="text" value="${a}"></td>
      <td><input class="input mono" type="text" value="${m}"></td>
      <td><button class="btn secondary">✕</button></td>`;
    tr.querySelector('button').onclick = ()=> tr.remove();
    tbody.appendChild(tr);
  }

  function loadExample(){
    tbody.innerHTML = '';
    // Classic small example: x ≡ 2 (mod 3), 3 (mod 5), 2 (mod 7)  →  x ≡ 23 (mod 105)
    addRow('2','3'); addRow('3','5'); addRow('2','7');
  }

  // number parsing (BigInt)
  function parsePos(bigStr){
    const s = String(bigStr).trim().replace(/[, _]/g,'');
    if (!/^-?\d+$/.test(s)) throw new Error(`Not an integer: ${bigStr}`);
    return BigInt(s);
  }

  // gcd + extended gcd, modular inverse
  function egcd(a,b){ // returns [g,x,y] with ax+by=g
    let old_r=a, r=b, old_s=1n, s=0n, old_t=0n, t=1n;
    while (r !== 0n){ const q = old_r / r;
      [old_r, r] = [r, old_r - q*r];
      [old_s, s] = [s, old_s - q*s];
      [old_t, t] = [t, old_t - q*t];
    }
    return [old_r, old_s, old_t];
  }
  function invMod(a, m){
    const [g, x] = egcd((a%m+m)%m, m);
    if (g !== 1n) throw new Error(`No inverse for ${a} mod ${m} (not coprime)`);
    return (x % m + m) % m;
  }
  function gcd(a,b){ while(b){ const t=a%b; a=b; b=t; } return a; }

  function pairwiseCoprime(ms){
    for (let i=0;i<ms.length;i++){
      for (let j=i+1;j<ms.length;j++){
        if (gcd(ms[i], ms[j]) !== 1n) return false;
      }
    }
    return true;
  }

  // ANSWER: combine using inverses (garner-style, iterative)
  function crtAnswer(as, ms){
    let x = ((as[0] % ms[0]) + ms[0]) % ms[0];
    let M = ms[0];
    for (let i=1;i<as.length;i++){
      const a = ((as[i] % ms[i]) + ms[i]) % ms[i];
      // solve: x + M*t ≡ a (mod m)
      const m = ms[i];
      const rhs = (a - (x % m) + m) % m;
      const inv = invMod(M % m, m);
      const t = (rhs * inv) % m;
      x = x + M * t;
      M = M * m;
      x %= M; // keep canonical representative
    }
    return [((x%M)+M)%M, M];
  }

  // CHECK: independent naive search (no inverses)
  // start with s ≡ a0 (mod m0), then step by M until meets a1 mod m1, etc.
  function crtNaiveCheck(as, ms, onProgress, onDone){
    let s = ((as[0] % ms[0]) + ms[0]) % ms[0];
    let M = ms[0];
    const start = performance.now();

    let i = 1;
    function step() {
      if (i >= as.length){
        const msElapsed = Math.round(performance.now() - start);
        onDone(s, M, msElapsed);
        return;
      }
      const a = ((as[i] % ms[i]) + ms[i]) % ms[i];
      const m = ms[i];

      // search t ≥ 0 minimal with s + M*t ≡ a (mod m)
      let t = 0n;
      const LIMIT = m;           // worst-case ≤ m steps when gcd(M,m)=1
      const CHUNK = 100000n;     // time-slicing

      function inner(){
        let steps = 0n;
        while (t < LIMIT && steps < CHUNK){
          if ( ((s + M*t) % m) === a ){ s = s + M*t; M = M*m; s %= M; i++; onProgress(i, as.length); setTimeout(step, 0); return; }
          t++; steps++;
        }
        if (t >= LIMIT){
          // should never happen if gcd(M,m)=1
          onDone(null, null, Math.round(performance.now()-start), `No solution when matching mod ${m}`);
          return;
        }
        // continue chunk
        setTimeout(inner, 0);
      }
      inner();
    }
    step();
  }

  function readSystem(){
    const as=[], ms=[];
    const rows=[...tbody.querySelectorAll('tr')];
    if (rows.length===0) throw new Error('Please add at least one congruence.');
    for (const r of rows){
      const a = parsePos(r.children[0].querySelector('input').value);
      const m = parsePos(r.children[1].querySelector('input').value);
      if (m <= 0n) throw new Error('Modulus must be positive.');
      as.push(a); ms.push(m);
    }
    if (!pairwiseCoprime(ms)) throw new Error('Moduli must be pairwise coprime.');
    return [as, ms];
  }

  function run(){
    resetUI();
    try{
      const [as, ms] = readSystem();

      // Compute Answer via inverses
      const [x, M] = crtAnswer(as, ms);
      answerEl.textContent = ` ${fmt(x)}  (mod ${fmt(M)})`;
      modulusEl.textContent = fmt(M);

      // Independent Check
      setStatus('running');
      runBtn.disabled = true;
      log(`→ naive check (no CRT, no inverses). Will match each congruence by stepping along arithmetic progressions…`);
      crtNaiveCheck(as, ms, (idx, n)=>{
        const pct = Math.floor(idx / n * 100);
        progEl.textContent = `${pct}%`;
      }, (s, Mcheck, msElapsed, err)=>{
        if (err){
          setStatus('mismatch', 'bad');
          checkEl.textContent = 'FAIL — no progressive match found';
          log('× '+err);
          runBtn.disabled = false;
          return;
        }
        log(`✓ naive reconstruction finished in ${msElapsed} ms`);
        const ansText = answerEl.textContent;
        // Extract numeric x from ansText
        const m = ms.reduce((p,c)=>p*c,1n);
        const xAns = ((as.length>0)? (ansText.match(/\s([\d,]+)\s\s\(mod/)||[])[1] : null);
        const xNum = s % m;
        const xStr = fmt(xNum);
        const ok = ansText.includes(` ${xStr} `) || ansText.includes(` ${xStr}\u00A0`);
        if (ok){
          setStatus('verified', 'ok');
          checkEl.textContent = 'PASS — independent search found the same residue';
        } else {
          setStatus('mismatch', 'bad');
          checkEl.textContent = 'FAIL — search residue differs from Answer';
          log(`expected: ${fmt(((xNum%m)+m)%m)}\nanswer  : ${ansText}`);
        }
        runBtn.disabled = false;
      });

    } catch(e){
      setStatus('bad input','bad');
      log('× '+(e && e.message ? e.message : e));
    }
  }

  // wiring
  addBtn.addEventListener('click', ()=> addRow());
  exBtn.addEventListener('click', loadExample);
  runBtn.addEventListener('click', run);
  // preload example
  loadExample();
})();
</script>
</body>
</html>


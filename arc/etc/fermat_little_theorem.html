<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fermat’s Little Theorem</title>
<style>
  :root{
    --bg:#f9fafb; --card:#ffffff; --ink:#111827; --ink-dim:#4b5563;
    --muted:#6b7280; --border:#e5e7eb; --code:#f3f4f6;
    --accent:#2563eb; --accent-ink:#ffffff; --ok:#16a34a; --warn:#dc2626;
    --badge:#e2e8f0; --badge-ink:#334155;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial}
  .wrap{max-width:900px;margin:0 auto;padding:28px 16px 40px}
  header{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:16px}
  header h1{margin:0;font-size:20px;font-weight:700;letter-spacing:.2px}
  .badge{background:var(--badge);color:var(--badge-ink);border:1px solid var(--border);padding:6px 10px;border-radius:999px;font-size:12px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:18px;box-shadow:0 10px 30px rgba(0,0,0,.04);margin-top:16px}
  .card h2{margin:0 0 12px;font-size:16px;letter-spacing:.2px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .input{background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px 12px;color:var(--ink);font-weight:600;min-width:120px}
  .input:focus{outline:3px solid rgba(37,99,235,.2);border-color:#93c5fd}
  .btn{background:var(--accent);color:var(--accent-ink);border:0;padding:10px 14px;font-weight:700;border-radius:12px;cursor:pointer}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .btn.secondary{background:#e5e7eb;color:#111827}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  .dim{color:var(--muted)}
  .kpi{font-weight:800}
  .stat{
    display:grid; grid-template-columns:auto 1fr; align-items:baseline; gap:8px;
    background:#fff; padding:8px 10px; border-radius:12px; border:1px solid var(--border);
  }
  #answer, #answer2{
    max-width:100%; white-space:normal; overflow-wrap:anywhere; word-break:break-word; line-break:anywhere;
    font-size:clamp(0.9rem, 1vw + 0.75rem, 1.1rem);
  }
  code,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
  pre{background:var(--code);border:1px solid var(--border);border-radius:12px;padding:14px;overflow:auto}
  .ok{color:var(--ok)} .bad{color:var(--warn)}
  .log{font-size:13px;max-height:240px;overflow:auto;background:var(--code);border:1px dashed var(--border);padding:10px;border-radius:12px;white-space:pre-wrap}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--border);background:#fff;color:var(--ink-dim);font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Fermat’s Little Theorem</h1>
  </header>

  <!-- Mathematical English -->
  <section class="card">
    <h2>Fermat’s Little Theorem</h2>
    <p class="dim">
      If <em>p</em> is prime and <em>a</em> is not divisible by <em>p</em>, then
      <strong>a<sup>p−1</sup> ≡ 1 (mod p)</strong>. A convenient corollary, valid for all integers <em>a</em>,
      is <strong>a<sup>p</sup> ≡ a (mod p)</strong>.
      We present these as the Answer (Lean reason: multiplicative group of <code>ZMod p</code>, Lagrange’s theorem),
      and independently confirm by direct modular exponentiation (Check).
    </p>
  </section>

  <!-- A · Answer -->
  <section class="card">
    <h2>Answer</h2>
    <div class="row" style="margin:10px 0 12px">
      <label class="dim" for="pInput">p (prime):</label>
      <input id="pInput" class="input mono" type="text" value="1009" inputmode="numeric" />
      <label class="dim" for="aInput">a (integer):</label>
      <input id="aInput" class="input mono" type="text" value="12345678901234567890" />
      <button id="runBtn" class="btn">Compute + Check</button>
    </div>

    <div class="stat" role="status" aria-live="polite">
      <span class="dim">a^(p−1) mod p (if gcd(a,p)=1) =</span>
      <span id="answer" class="kpi mono">–</span>
    </div>
    <div class="stat" role="status" aria-live="polite" style="margin-top:8px">
      <span class="dim">a^p mod p (holds for all a) =</span>
      <span id="answer2" class="kpi mono">–</span>
    </div>
    <p class="dim" id="primeNote"></p>
  </section>

  <!-- R · Reason why -->
  <section class="card">
    <h2>Reason why (Lean 4 sketch)</h2>
    <p class="dim">
      In <code>ZMod p</code> with <em>p</em> prime, the nonzero classes form a multiplicative group of size <em>p−1</em>.
      By Lagrange’s theorem, for any nonzero <em>a</em> we have <em>a<sup>p−1</sup>=1</em> in that group, i.e.
      <em>a<sup>p−1</sup> ≡ 1 (mod p)</em>. Multiplying by <em>a</em> gives <em>a<sup>p</sup> ≡ a</em>.
    </p>
<pre><code>-- Lean 4 sketch of Fermat’s Little Theorem
import Mathlib
open ZMod

theorem fermat_little (p : ℕ) (hp : Nat.Prime p) (a : ℤ)
    (h0 : (a : ZMod p) ≠ 0) :
  ((a : ZMod p)^(p-1)) = 1 := by
  -- In (ZMod p)ˣ, Lagrange’s theorem gives u^(p-1)=1 for every unit u.
  -- The hypothesis h0 ensures a is a unit, hence the claim.
  admit

theorem fermat_little_cor (p : ℕ) (hp : Nat.Prime p) (a : ℤ) :
  ((a : ZMod p)^p) = (a : ZMod p) := by
  -- Multiply the previous equality by a (treating the zero case separately).
  admit
</code></pre>
    <p class="dim">The snippet captures the formal reason; the browser doesn’t execute Lean.</p>
  </section>

  <!-- C · Check (independent harness) -->
  <section class="card">
    <h2>Check (independent harness)</h2>
    <p class="dim">
      Without using FLT, we compute <code>a^(p−1) mod p</code> and <code>a^p mod p</code> directly (BigInt fast
      exponentiation), and we run a primality test for <em>p</em>. PASS means the direct values match the theorem’s predictions.
    </p>

    <div class="row" style="margin-bottom:8px">
      <div id="statusPill" class="pill">idle</div>
      <div><span class="dim">progress:</span> <span id="progress" class="mono">0%</span></div>
    </div>
    <div id="log" class="log mono" aria-live="polite"></div>

    <h3>Result</h3>
    <p><span class="dim">Check status:</span> <strong id="checkStatus">–</strong></p>
  </section>
</div>

<script>
(function () {
  const pInput   = document.getElementById('pInput');
  const aInput   = document.getElementById('aInput');
  const runBtn   = document.getElementById('runBtn');
  const answerEl = document.getElementById('answer');
  const answer2El= document.getElementById('answer2');
  const primeNote= document.getElementById('primeNote');
  const logEl    = document.getElementById('log');
  const progEl   = document.getElementById('progress');
  const pillEl   = document.getElementById('statusPill');
  const checkEl  = document.getElementById('checkStatus');

  function setStatus(text, kind) {
    pillEl.textContent = text;
    pillEl.style.borderColor = 'var(--border)';
    if (kind === 'ok') { pillEl.style.background = '#dcfce7'; pillEl.style.color = 'var(--ok)'; }
    else if (kind === 'bad') { pillEl.style.background = '#fee2e2'; pillEl.style.color = 'var(--warn)'; }
    else { pillEl.style.background = '#fff'; pillEl.style.color = 'var(--ink-dim)'; }
  }
  function log(line){ logEl.textContent += line + '\n'; logEl.scrollTop = logEl.scrollHeight; }
  function resetUI(){ logEl.textContent=''; progEl.textContent='0%'; checkEl.textContent='–'; checkEl.className=''; setStatus('idle'); primeNote.textContent=''; }

  // --- BigInt helpers ---
  function parseIntBI(s){
    const t = String(s).trim().replace(/[, _]/g,'');
    if (!/^-?\d+$/.test(t)) throw new Error('Please enter an integer.');
    return BigInt(t);
  }
  function parsePosInt(s){
    const t = String(s).trim().replace(/[, _]/g,'');
    if (!/^\d+$/.test(t)) throw new Error('Please enter a positive integer for p.');
    const n = BigInt(t);
    if (n <= 1n) throw new Error('p must be ≥ 2.');
    return n;
  }
  function normMod(x, m){ return ((x % m) + m) % m; }
  function mulMod(a,b,m){ return (a*b) % m; }
  function powMod(a,e,m){
    let x = 1n, y = normMod(a,m), k = e;
    while (k > 0n){ if (k & 1n) x = (x*y)%m; y = (y*y)%m; k >>= 1n; }
    return x;
  }

  // Deterministic Miller–Rabin for < 2^64
  function isPrime(n){
    if (n < 2n) return false;
    const small = [2n,3n,5n,7n,11n,13n,17n,19n,23n,29n,31n,37n];
    for (const p of small){ if (n === p) return true; if (n % p === 0n) return n === p; }
    // write n-1 = d*2^s with d odd
    let d = n - 1n, s = 0n;
    while ((d & 1n) === 0n){ d >>= 1n; s++; }
    const bases = [2n,3n,5n,7n,11n,13n,17n]; // good for < 2^64
    for (let a of bases){
      if (a % n === 0n) continue;
      let x = powMod(a, d, n);
      if (x === 1n || x === n-1n) continue;
      let cont = false;
      for (let r=1n; r<s; r++){
        x = (x*x) % n;
        if (x === n-1n){ cont = true; break; }
      }
      if (!cont) return false;
    }
    return true;
  }

  function run(){
    resetUI();
    let p, a;
    try { p = parsePosInt(pInput.value); a = parseIntBI(aInput.value); }
    catch(e){ setStatus('bad input','bad'); log('× '+e.message); return; }

    const prime = isPrime(p);
    const aMod = normMod(a, p);

    // Answer (by theorem)
    if (prime) {
      primeNote.textContent = 'p is prime. If a ≢ 0 (mod p), FLT says a^(p−1) ≡ 1 (mod p); always a^p ≡ a (mod p).';
      if (aMod !== 0n) answerEl.textContent = '1'; else answerEl.textContent = '(not applicable: a ≡ 0 mod p)';
      answer2El.textContent = aMod.toString();
    } else {
      primeNote.textContent = 'p is not prime. FLT does not apply; we still compute powers modulo p.';
      answerEl.textContent = '—';
      answer2El.textContent = aMod.toString(); // for composites, a^p ≡ a need not hold
    }

    // Independent Check (direct powmod, no FLT)
    setStatus('running');
    runBtn.disabled = true;
    log('→ computing modular powers directly (no theorem)…');
    progEl.textContent = '50%';

    // direct computation
    const val1 = (p > 1n) ? powMod(a, p-1n, p) : 0n;
    const val2 = powMod(a, p, p);

    progEl.textContent = '100%';
    log(`a^(p−1) mod p = ${val1}`);
    log(`a^p mod p     = ${val2}`);

    if (prime){
      const pass1 = (aMod === 0n) ? true : (val1 === 1n);
      const pass2 = (val2 === aMod);
      if (pass1 && pass2){
        setStatus('verified','ok');
        checkEl.textContent = 'PASS — direct powers match Fermat’s Little Theorem';
      } else {
        setStatus('mismatch','bad');
        checkEl.textContent = 'FAIL — mismatch with theorem predictions';
      }
    } else {
      setStatus('done','ok');
      checkEl.textContent = 'Computed values shown (p not prime).';
    }
    runBtn.disabled = false;
  }

  runBtn.addEventListener('click', run);
})();
</script>
</body>
</html>


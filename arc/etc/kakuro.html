<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kakuro (Cross Sums) — ARC</title>
<style>
  :root {
    --bg:#f7f9fc; --card:#ffffff; --muted:#5b6b87; --text:#0f172a; --border:#e5e7eb; --accent:#0ea5e9; --ink:#111827;
    --cell: 58px; /* ↑ bigger solution grid cells */
  }
  html,body{height:100%;background:var(--bg);color:var(--text);font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif}
  h1{font-weight:700;margin:18px 0 6px}
  h2{font-size:13px;color:var(--muted);margin:0 0 8px;letter-spacing:.2px;text-transform:uppercase}
  .wrap{max-width:1150px;margin:0 auto;padding:24px}
  .stack{display:grid;grid-template-columns:1fr;gap:14px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px;box-shadow:0 6px 20px rgba(0,0,0,.04)}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  button{border:0;background:linear-gradient(180deg,#7dd3fc,#38bdf8);color:#052436;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 3px 12px rgba(56,189,248,.35)}
  button.secondary{background:#f3f4f6;color:#111827;border:1px solid var(--border);box-shadow:none}
  .output{min-height:0;white-space:pre-wrap;background:#fbfdff;border:1px solid var(--border);border-radius:10px;padding:10px;overflow:auto}
  .output.tall{min-height:180px}
  .muted{color:var(--muted)}
  .tiny{font-size:12px}
  .badge{display:inline-block;border:1px solid var(--border);background:#f5f7fb;color:#334155;border-radius:999px;padding:2px 8px;font-size:12px;font-weight:700;letter-spacing:.3px}
  textarea,pre,code,input,button{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,"Courier New",monospace}
  textarea{width:100%;min-height:0;height:auto;overflow:hidden;resize:none;border-radius:10px;padding:10px;border:1px solid var(--border);background:#fbfdff;color:#0f172a;box-sizing:border-box;white-space:pre-wrap}

  /* Solution grid */
  .grid{display:grid;gap:0}
  .cell{
    width:var(--cell);height:var(--cell);
    display:flex;align-items:center;justify-content:center;
    border:1px solid #cbd5e1;background:#fff;
    font-weight:800;color:#0f172a;position:relative;border-radius:6px;
    box-shadow:0 2px 10px rgba(0,0,0,.05);
  }
  .cell .num{position:relative;z-index:1}
  .black{background:#0f172a;color:#e2e8f0;border-radius:6px}
  .label{
    position:absolute;top:4px;left:6px;
    font-size:10px; font-weight:800; color:#334155; opacity:.9;
    padding:0 5px;border-radius:999px; background:rgba(255,255,255,.6); backdrop-filter:saturate(1.2) blur(1px);
  }

  /* Small color chips for legend (optional if you add one later) */
  .chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);border-radius:999px;padding:2px 8px;background:#f5f7fb}
  .dot{width:12px;height:12px;border-radius:999px;border:1px solid rgba(0,0,0,.1)}
</style>
</head>
<body>
<div class="wrap">
  <h1>Kakuro (Cross Sums) — ARC</h1>

  <div class="stack">

    <!-- What this is? -->
    <div class="card">
      <h2>What this is?</h2>
      <p>A one-file, pure JS + JSON solver for a Kakuro puzzle. Each <em>run</em> (contiguous white cells left→right or top→bottom) must sum to its clue with <b>distinct digits 1–9</b>. We generate all valid digit tuples per run, propagate across intersections, and use DFS if needed. The page explains why digits are forced and verifies the result.</p>
      <ul>
        <li><b>Data</b> — <code>size</code> and a list of <code>runs</code>, each with <code>id</code>, <code>sum</code>, and <code>cells</code> (1-based <code>[row,col]</code>).</li>
        <li><b>Policies</b> — declarative families: run-sum + all-different, digits ∈ {1..9}, intersection consistency.</li>
        <li><b>Answer</b> — derived facts (<code>cell(r,c)=d</code>).</li>
        <li><b>Reason Why</b> — which runs/tuples forced which digits.</li>
        <li><b>Check</b> — 12+ validations (sums, distinctness, bounds, completeness).</li>
        <li><b>Solution Summary</b> — now **larger** with **colors**: each cell shows a diagonal blend of its horizontal (↘) and vertical (↗) run colors.</li>
        <li><b>Uniqueness</b> — optional probe for a different second solution.</li>
      </ul>
      <p class="tiny muted">This demo uses a fully white 5×5 grid with row/column runs only (sum=15). That forces each run to be a permutation of {1,2,3,4,5}, and intersections behave like a 5×5 Latin puzzle.</p>
    </div>

    <!-- NEW: Puzzle details -->
    <div class="card">
      <h2>Puzzle Details</h2>
      <ul>
        <li><b>Size:</b> 5×5 (editable in Data).</li>
        <li><b>Runs:</b> 10 total — 5 horizontal (R1–R5) and 5 vertical (C1–C5), each length 5 with sum 15.</li>
        <li><b>Digits:</b> 1–9, pairwise distinct within each run.</li>
        <li><b>Editing:</b> Replace <code>runs</code> with any Kakuro layout; any cell not present in any run renders as a black cell.</li>
        <li><b>Colors:</b> Horizontal and vertical runs are colored with a pastel palette; cells show a diagonal split to indicate both memberships. Labels display the run IDs and sums on first cells.</li>
      </ul>
    </div>

    <div class="card">
      <h2>Data (JSON)</h2>
      <textarea id="dataTA" spellcheck="false">{
  "size": 5,
  "runs": [
    { "id": "R1", "sum": 15, "cells": [[1,1],[1,2],[1,3],[1,4],[1,5]] },
    { "id": "R2", "sum": 15, "cells": [[2,1],[2,2],[2,3],[2,4],[2,5]] },
    { "id": "R3", "sum": 15, "cells": [[3,1],[3,2],[3,3],[3,4],[3,5]] },
    { "id": "R4", "sum": 15, "cells": [[4,1],[4,2],[4,3],[4,4],[4,5]] },
    { "id": "R5", "sum": 15, "cells": [[5,1],[5,2],[5,3],[5,4],[5,5]] },

    { "id": "C1", "sum": 15, "cells": [[1,1],[2,1],[3,1],[4,1],[5,1]] },
    { "id": "C2", "sum": 15, "cells": [[1,2],[2,2],[3,2],[4,2],[5,2]] },
    { "id": "C3", "sum": 15, "cells": [[1,3],[2,3],[3,3],[4,3],[5,3]] },
    { "id": "C4", "sum": 15, "cells": [[1,4],[2,4],[3,4],[4,4],[5,4]] },
    { "id": "C5", "sum": 15, "cells": [[1,5],[2,5],[3,5],[4,5],[5,5]] }
  ]
}</textarea>
      <p class="tiny muted">You can switch to a shaped Kakuro: just list all horizontal and vertical runs; any grid cell not in any run becomes a black cell.</p>
    </div>

    <div class="card">
      <h2>Policies (declarative JSON rules)</h2>
      <textarea id="policyTA" spellcheck="false">[
  { "id":"K1-RunSumAllDiff",
    "explain":"In every run, digits are in {1..9}, pairwise distinct, and their sum equals the run clue."
  },
  { "id":"K2-Intersections",
    "explain":"Each white cell belongs to 1 horizontal and 1 vertical run; the digit must satisfy both runs."
  },
  { "id":"K3-Propagation",
    "explain":"A digit not supported by any valid run tuple is removed from the cell's domain."
  }
]</textarea>
    </div>

    <div class="card">
      <h2>Controls</h2>
      <div class="row">
        <button id="runBtn">▶ Run ARC</button>
        <label class="switch"><input id="uniqChk" type="checkbox"/> Probe uniqueness (second solution)</label>
        <button id="reasonBtn" class="secondary">Show Reason only</button>
        <span id="status" class="muted tiny" style="margin-left:auto"></span>
      </div>
      <div id="diag" class="tiny" style="color:#6b7280"></div>
    </div>

    <div class="card">
      <h2>Answer (newly derived facts)</h2>
      <div id="answer" class="output tall">computing…</div>
    </div>

    <div class="card">
      <h2>Reason Why (mathematical English)</h2>
      <div id="reason" class="output tall">(click “Run ARC”)</div>
    </div>

    <div class="card">
      <h2>Check <span id="checksCount" class="badge">0</span></h2>
      <div id="checks" class="output tall">computing…</div>
    </div>

    <div class="card">
      <h2>Solution Summary</h2>
      <div id="gridHost" class="output">
        <div id="gridMount"></div>
      </div>
    </div>

    <div class="card">
      <h2>Uniqueness Probe</h2>
      <div id="uniqOut" class="output">(toggle “Probe uniqueness” then Run)</div>
    </div>

  </div>
</div>

<script>
const $ = id => document.getElementById(id);
const els = {
  dataTA: $("dataTA"), policyTA: $("policyTA"),
  runBtn: $("runBtn"), reasonBtn: $("reasonBtn"), uniqChk: $("uniqChk"),
  status: $("status"), diag: $("diag"),
  answer: $("answer"), reason: $("reason"), checks: $("checks"),
  checksCount: $("checksCount"), checksCountInline: $("checksCountInline"),
  gridMount: $("gridMount"), uniqOut: $("uniqOut")
};

// Auto-grow textareas
function autoResize(el){ el.style.height='auto'; el.style.height=el.scrollHeight+'px'; }
["dataTA","policyTA"].forEach(id=>{
  const el=$(id); el.addEventListener('input',()=>autoResize(el)); setTimeout(()=>autoResize(el),0);
});

// ---- Utils
function parseJSON(text, label){
  try { return JSON.parse(text); }
  catch(e){ throw new Error(`${label} JSON error: ${e.message}`); }
}

function setEq(a,b){ if(a.size!==b.size) return false; for(const x of a) if(!b.has(x)) return false; return true; }

// Generate strictly increasing combinations of digits 1..9 length k summing to S
function combos(k, S, start=1){
  const out=[];
  function rec(pos, next, sum, acc){
    if(pos===k){ if(sum===S) out.push(acc.slice()); return; }
    for(let d=next; d<=9; d++){
      if(sum + d + (k-pos-1)*(d+1) > S) break; // optimistic bound
      if(sum + d + (k-pos-1)*9 < S) continue;  // pessimistic bound
      acc.push(d); rec(pos+1, d+1, sum+d, acc); acc.pop();
    }
  }
  rec(0, start, 0, []);
  return out;
}

// All permutations (k ≤ 9; here k is small)
function perms(arr){
  const out=[];
  function rec(a, l){
    if(l===a.length-1){ out.push(a.slice()); return; }
    for(let i=l;i<a.length;i++){
      [a[l],a[i]]=[a[i],a[l]]; rec(a,l+1); [a[l],a[i]]=[a[i],a[l]];
    }
  }
  rec(arr.slice(),0);
  return out;
}

function key(r,c){ return `${r},${c}`; }

function buildIndex(size, runs){
  const cellRuns = new Map(); // "r,c" -> [runIds...]
  const runById = new Map();
  const runOrient = new Map(); // id -> "H" or "V"
  for(const run of runs){
    runById.set(run.id, run);
    // Orientation heuristic: compare first two cells if possible
    let orient="H";
    if(run.cells.length>=2){
      const [r1,c1] = run.cells[0], [r2,c2] = run.cells[1];
      orient = (r1===r2) ? "H" : "V";
    }
    runOrient.set(run.id, orient);
    for(const [r,c] of run.cells){
      const k = key(r,c);
      if(!cellRuns.has(k)) cellRuns.set(k, []);
      cellRuns.get(k).push(run.id);
    }
  }
  return {cellRuns, runById, runOrient};
}

// Valid tuples for a run given cell domains
function validTuples(run, domains){
  const k = run.cells.length;
  const base = combos(k, run.sum);
  const tuples=[];
  const cells = run.cells.map(([r,c])=> domains.get(key(r,c)));
  for(const comb of base){
    // quick feasibility vs domains
    let okUnion=true;
    const allVals = new Set(comb);
    for(const s of cells){
      let hit=false; for(const v of s){ if(allVals.has(v)){ hit=true; break; } }
      if(!hit){ okUnion=false; break; }
    }
    if(!okUnion) continue;
    for(const p of perms(comb)){
      let ok=true; for(let i=0;i<k;i++){ if(!cells[i].has(p[i])){ ok=false; break; } }
      if(ok) tuples.push(p);
    }
  }
  return tuples;
}

// Propagation
function propagate(size, runs, domains, reasons){
  while(true){
    let changed=false;
    for(const run of runs){
      const tups = validTuples(run, domains);
      if(tups.length===0) return {progress:false, contradiction:true};
      const k = run.cells.length;
      const support = Array.from({length:k}, ()=> new Set());
      for(const t of tups){ for(let i=0;i<k;i++) support[i].add(t[i]); }
      for(let i=0;i<k;i++){
        const [r,c] = run.cells[i]; const K = key(r,c);
        const dom = domains.get(K);
        const before = new Set(dom);
        for(const v of Array.from(dom)){ if(!support[i].has(v)) dom.delete(v); }
        if(dom.size===0) return {progress:false, contradiction:true};
        if(dom.size !== before.size){
          const removed = [...before].filter(v=>!dom.has(v));
          reasons.push(`Run ${run.id} (sum=${run.sum}, len=${k}) prunes cell(${r},${c}) ← remove {${removed.join(",")}}.`);
          changed=true;
        }
        if(dom.size===1 && before.size!==1){
          reasons.push(`Run ${run.id} forces cell(${r},${c}) = ${[...dom][0]}.`);
        }
      }
    }
    if(!changed) return {progress:false, contradiction:false};
  }
}

function cloneDomains(domains){ const m = new Map(); for(const [k,v] of domains) m.set(k, new Set(v)); return m; }
function isSolved(domains){ for(const s of domains.values()) if(s.size!==1) return false; return true; }
function pickCell(domains){ let pick=null, min=99; for(const [k,s] of domains){ if(s.size>1 && s.size<min){ min=s.size; pick=k; } } return pick; }
function equalSolutions(a,b){ for(const [k,s] of a){ const t=b.get(k); if(!t||!setEq(s,t)) return false; } return true; }

function solve(size, runs, domains, forbid=null){
  const reasons=[];
  const step = propagate(size, runs, domains, reasons);
  if(step.contradiction) return null;

  if(isSolved(domains)){
    if(forbid && equalSolutions(domains, forbid)) return null;
    return {domains, reasons};
  }

  const cell = pickCell(domains);
  if(!cell) return null;
  const options = Array.from(domains.get(cell));
  for(const v of options){
    const next = cloneDomains(domains);
    next.get(cell).clear(); next.get(cell).add(v);
    const sub = solve(size, runs, next, forbid);
    if(sub){
      sub.reasons.unshift(`Branch on cell(${cell}) = ${v}.`);
      return sub;
    }
  }
  return null;
}

// Build initial domains (1..9 for every white cell)
function initDomains(size, runs){
  const white = new Set();
  for(const run of runs) for(const [r,c] of run.cells) white.add(key(r,c));
  const domains = new Map();
  for(let r=1;r<=size;r++){
    for(let c=1;c<=size;c++){
      const k = key(r,c);
      if(white.has(k)) domains.set(k, new Set([1,2,3,4,5,6,7,8,9]));
    }
  }
  return {domains, white};
}

// Pretty colors for runs
function hsl(h,s,l){ return `hsl(${h} ${s}% ${l}%)`; }
function runColors(runs){
  const ids = runs.map(r=>r.id);
  const n = ids.length||1;
  const map = new Map();
  for(let i=0;i<ids.length;i++){
    const hue = Math.round((i*360/n + 8) % 360);
    map.set(ids[i], {
      bg: hsl(hue, 85, 90),   // pastel fill
      stroke: hsl(hue, 55, 40) // text/badge
    });
  }
  return map;
}

// Render grid with diagonal color blend (H vs V run)
function renderGrid(size, runs, domains){
  const g = document.createElement('div');
  g.className = 'grid';
  g.style.gridTemplateColumns = `repeat(${size}, var(--cell))`;

  const {cellRuns, runById, runOrient} = buildIndex(size, runs);
  const colors = runColors(runs);

  const white = new Set();
  for(const run of runs) for(const [r,c] of run.cells) white.add(key(r,c));

  // Label map at first cell of each run
  const labelAt = new Map(); // "r,c" -> ["R1=15", "C3=23", ...]
  for(const run of runs){
    const [r,c] = run.cells[0];
    const k = key(r,c);
    if(!labelAt.has(k)) labelAt.set(k, []);
    labelAt.get(k).push(`${run.id}=${run.sum}`);
  }

  for(let r=1;r<=size;r++){
    for(let c=1;c<=size;c++){
      const k = key(r,c);
      const cellDiv = document.createElement('div');
      cellDiv.className = 'cell';

      if(!white.has(k)){
        cellDiv.classList.add('black');
        cellDiv.textContent = '■';
        g.appendChild(cellDiv);
        continue;
      }

      // Value
      const dom = domains.get(k);
      const val = dom && dom.size===1 ? [...dom][0] : '';
      const num = document.createElement('div');
      num.className = 'num';
      num.textContent = val;
      cellDiv.appendChild(num);

      // Colors: blend horizontal (↘) and vertical (↗) if available
      const runsHere = (cellRuns.get(k) || []);
      let colH = null, colV = null;
      for(const rid of runsHere){
        const o = runOrient.get(rid);
        if(o==="H") colH = colors.get(rid)?.bg || colH;
        if(o==="V") colV = colors.get(rid)?.bg || colV;
      }
      // Fallbacks
      if(!colH && colV) colH = colV;
      if(!colV && colH) colV = colH;
      if(!colH && !colV){ colH = '#fff'; colV = '#fff'; }

      cellDiv.style.background = `linear-gradient(135deg, ${colH} 0 50%, ${colV} 50% 100%)`;

      // Label on first cell(s) of run(s)
      if(labelAt.has(k)){
        const lab = document.createElement('div');
        lab.className = 'label';
        lab.textContent = labelAt.get(k).join(' • ');
        cellDiv.appendChild(lab);
      }

      g.appendChild(cellDiv);
    }
  }
  return g;
}

// Reporting
function facts(domains){
  const out=[];
  for(const [k,s] of domains){
    const [r,c] = k.split(',').map(Number);
    out.push(`cell(${r},${c}) = ${[...s][0]}`);
  }
  return out.sort().join("\n");
}
function explain(reasons){ return reasons.join("\n"); }

function checks(size, runs, domains){
  const out=[];
  // Assigned & range
  let allAssigned = true, inRange = true;
  for(const [k,s] of domains){ if(s.size!==1) allAssigned=false; const v=[...s][0]; if(v<1||v>9) inRange=false; }
  out.push({name:"All white cells assigned", pass:allAssigned});
  out.push({name:"Digits within 1..9", pass:inRange});

  // For each run: sum & distinctness
  for(const run of runs){
    const vals = run.cells.map(([r,c])=>[...domains.get(key(r,c))][0]);
    const sumOK = vals.reduce((a,b)=>a+b,0)===run.sum;
    const distinct = (new Set(vals)).size===vals.length;
    out.push({name:`Run ${run.id} sum`, pass:sumOK});
    out.push({name:`Run ${run.id} all-different`, pass:distinct});
  }

  // Coverage sanity
  const white = new Set(); for(const run of runs) for(const [r,c] of run.cells) white.add(key(r,c));
  out.push({name:"White cell coverage consistent", pass: domains.size===white.size});

  // Diagnostics: digit frequencies
  const freq = new Map(); for(const [k,s] of domains){ const v=[...s][0]; freq.set(v,(freq.get(v)||0)+1); }
  for(const d of [1,2,3,4,5,6,7,8,9]){
    out.push({name:`Digit ${d} frequency (diagnostic)`, pass: (freq.get(d)||0) >= 0});
  }
  return out;
}

function renderChecks(list){
  const lines = list.map((r,i)=> `${r.pass? "✅":"❌"} ${String(i+1).padStart(2," ")} — ${r.name}`);
  const passCt = list.filter(x=>x.pass).length;
  lines.push(`\nSummary: ${passCt}/${list.length} PASS`);
  return lines.join("\n");
}

// Orchestrate
function runARC(){
  els.status.textContent = "Parsing JSON…";
  els.answer.textContent = els.reason.textContent = els.checks.textContent = "computing…";
  els.gridMount.innerHTML = ""; els.uniqOut.textContent = "(toggle “Probe uniqueness” then Run)";
  els.diag.textContent = "";

  try{
    const data = parseJSON(els.dataTA.value, "Data");
    parseJSON(els.policyTA.value, "Policies");
    const size = data.size|0;
    if(!(Number.isInteger(size) && size>0)) throw new Error("size must be a positive integer");
    if(!Array.isArray(data.runs) || data.runs.length===0) throw new Error("runs must be a non-empty array");

    const {domains} = initDomains(size, data.runs);
    els.status.textContent = "Solving…";
    const sol = solve(size, data.runs, domains, null);
    if(!sol) throw new Error("No solution found (check runs).");
    const {domains:solution, reasons} = sol;

    els.answer.textContent = facts(solution);
    els.reason.textContent = explain(reasons);

    const chk = checks(size, data.runs, solution);
    els.checks.textContent = renderChecks(chk);
    els.checksCount.textContent = String(chk.length);
    if(els.checksCountInline) els.checksCountInline.textContent = String(chk.length);

    els.gridMount.appendChild(renderGrid(size, data.runs, solution));

    if(els.uniqChk.checked){
      els.status.textContent = "Probing uniqueness…";
      const {domains:dom2} = initDomains(size, data.runs);
      const alt = solve(size, data.runs, dom2, solution);
      els.uniqOut.textContent = alt ? "Multiple solutions found — this clue set is under-constrained." : "Unique — no second distinct solution found.";
    }

    els.status.textContent = "Done.";
  } catch(e){
    els.status.textContent = "Error";
    els.answer.textContent = "(failed)";
    els.reason.textContent = "(failed)";
    els.checks.textContent = "(failed)";
    els.gridMount.innerHTML = "";
    els.uniqOut.textContent = "(failed)";
    els.diag.textContent = e.message;
    console.error(e);
  }

  autoResize(els.dataTA); autoResize(els.policyTA);
}

function showReasonOnly(){
  runARC();
  setTimeout(()=> window.scrollTo({top: $("reason").getBoundingClientRect().top + window.scrollY - 12, behavior:"smooth"}), 50);
}

els.runBtn.addEventListener('click', runARC);
els.reasonBtn.addEventListener('click', showReasonOnly);
window.addEventListener('DOMContentLoaded', runARC);
</script>
</body>
</html>


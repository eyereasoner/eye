<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Order of a Permutation = LCM of Cycle Lengths</title>
<style>
  :root{
    --bg:#f9fafb; --card:#ffffff; --ink:#111827; --ink-dim:#4b5563;
    --muted:#6b7280; --border:#e5e7eb; --code:#f3f4f6;
    --accent:#2563eb; --accent-ink:#ffffff; --ok:#16a34a; --warn:#dc2626;
    --badge:#e2e8f0; --badge-ink:#334155;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial}
  .wrap{max-width:900px;margin:0 auto;padding:28px 16px 40px}
  header{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:16px}
  header h1{margin:0;font-size:20px;font-weight:700;letter-spacing:.2px}
  .badge{background:var(--badge);color:var(--badge-ink);border:1px solid var(--border);padding:6px 10px;border-radius:999px;font-size:12px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:18px;box-shadow:0 10px 30px rgba(0,0,0,.04);margin-top:16px}
  .card h2{margin:0 0 12px;font-size:16px;letter-spacing:.2px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .input{background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px 12px;color:var(--ink);font-weight:600;min-width:120px}
  .input:focus{outline:3px solid rgba(37,99,235,.2);border-color:#93c5fd}
  .btn{background:var(--accent);color:var(--accent-ink);border:0;padding:10px 14px;font-weight:700;border-radius:12px;cursor:pointer}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .btn.secondary{background:#e5e7eb;color:#111827}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  .dim{color:var(--muted)}
  .kpi{font-weight:800}
  .stat{
    display:grid; grid-template-columns:auto 1fr; align-items:baseline; gap:8px;
    background:#fff; padding:8px 10px; border-radius:12px; border:1px solid var(--border);
  }
  #answer{
    max-width:100%; white-space:normal; overflow-wrap:anywhere; word-break:break-word; line-break:anywhere;
    font-size:clamp(0.9rem, 1vw + 0.75rem, 1.1rem);
  }
  textarea{width:100%; min-height:110px; resize:vertical; background:#fff; border:1px solid var(--border); border-radius:12px; padding:10px; font:14px/1.35 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono"}
  code,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
  pre{background:var(--code);border:1px solid var(--border);border-radius:12px;padding:14px;overflow:auto}
  .ok{color:var(--ok)} .bad{color:var(--warn)}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--border);background:#fff;color:var(--ink-dim);font-size:12px}
  .log{font-size:13px;max-height:240px;overflow:auto;background:var(--code);border:1px dashed var(--border);padding:10px;border-radius:12px;white-space:pre-wrap}
  .kv{display:flex; gap:10px; flex-wrap:wrap}
  .kv .tag{background:#eef2ff;border:1px solid #e5e7eb;border-radius:999px;padding:4px 8px;font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Order of a Permutation</h1>
  </header>

  <!-- NEW: Clarification / Mathematical English -->
  <section class="card">
    <p class="dim">
      <strong>Order of a permutation.</strong> For a permutation π, the order ord(π) is the least m ≥ 1
      such that π^m = id (the identity permutation). It is the number of iterations needed for every
      element to return to its starting point.
    </p>
    <p class="dim">
      <strong>Theorem.</strong> If π decomposes into disjoint cycles of lengths ℓ₁,…,ℓᵣ (counting fixed points
      as 1-cycles), then <strong>ord(π) = lcm(ℓ₁,…,ℓᵣ)</strong>. On each cycle of length ℓ we have π^k = id
      exactly when ℓ divides k; since cycles act independently, π^k = id iff every ℓᵢ divides k, so the minimal such k is the LCM.
    </p>
    <p class="dim">
      <strong>What this page verifies.</strong> For your input permutation, it computes L = lcm of the cycle lengths,
      checks that π^L = id, and then tries to divide out prime factors of L. If removing any factor breaks the identity,
      L is minimal, hence equals ord(π).
    </p>
    <h2>How the cycles are obtained (and what LCM means)</h2>
    <p class="dim">
      A <strong>cycle</strong> of a permutation π on {1,…,n} is found by starting at some unused element a,
      then following a → π(a) → π²(a) → … until you return to a for the first time. If this happens after ℓ steps,
      you record the cycle as (a₁ a₂ … a_ℓ) with π(aᵢ)=aᵢ₊₁ and π(a_ℓ)=a₁. Repeat from the next smallest unused element
      until all elements are in exactly one cycle. (Fixed points are 1-cycles.)
      The <strong>least common multiple (LCM)</strong> of positive integers ℓ₁,…,ℓ<sub>r</sub> is the smallest positive
      integer divisible by each ℓ<sub>i</sub>.
    </p>
    <details>
      <summary class="dim">Worked example (from one-line notation to cycles and order)</summary>
      <div style="margin-top:10px">
        <p class="dim">One-line notation (the i-th number is π(i)):</p>
        <pre class="mono">13 17 16 5 15 7 18 14 11 3 4 8 6 9 12 19 20 1 10 2</pre>
        <p class="dim">Follow arrows until returning to the start in each case:</p>
        <pre class="mono">
Start at 1:  1 → 13 → 6 → 7 → 18 → 1      ⇒ (1 13 6 7 18)     · ℓ=5
Start at 2:  2 → 17 → 20 → 2               ⇒ (2 17 20)         · ℓ=3
Start at 3:  3 → 16 → 19 → 10 → 3          ⇒ (3 16 19 10)      · ℓ=4
Start at 4:  4 → 5 → 15 → 12 → 8 → 14 → 9 → 11 → 4
                                          ⇒ (4 5 15 12 8 14 9 11) · ℓ=8
        </pre>
        <p class="dim">Thus the cycle lengths are 5, 3, 4, 8 and the order is their LCM:</p>
        <pre class="mono">ord(π) = lcm(5,3,4,8) = 120</pre>
      </div>
    </details>
  </section>

  <!-- A · Answer -->
  <section class="card">
    <h2>Answer</h2>
    <p class="dim">
      Give a permutation on <span class="mono">n</span> elements (1-based mapping: the i-th number is π(i)).
      Use the randomizer to fill the box.
    </p>
    <div class="row" style="margin:10px 0 12px">
      <label class="dim" for="nInput">n:</label>
      <input id="nInput" class="input mono" type="text" value="20" inputmode="numeric" />
      <button id="randBtn" class="btn secondary">Random permutation</button>
      <button id="runBtn" class="btn">Compute + Check</button>
    </div>

    <textarea id="permText" placeholder="Example for n=5: 2 3 1 5 4"></textarea>

    <div class="stat" role="status" aria-live="polite" style="margin-top:12px">
      <span class="dim">ord(π) =</span>
      <span id="answer" class="kpi mono">–</span>
    </div>

    <div id="cycles" class="kv" style="margin-top:10px"></div>
  </section>

  <!-- R · Reason why -->
  <section class="card">
    <h2>Reason why (Lean 4 sketch)</h2>
    <p class="dim">
      A permutation decomposes into disjoint cycles. On a cycle of length ℓ, the power πᵏ is the identity exactly when ℓ ∣ k.
      Since cycles are disjoint, powers act independently, hence the smallest k with πᵏ = id is the least common multiple of
      the cycle lengths.
    </p>
<pre><code>-- Lean 4 sketch: order of a permutation = lcm of cycle lengths
import Mathlib
open scoped BigOperators
open Finset

/-- For a finite type `α`, the order of `σ : Equiv.Perm α` is the lcm of the lengths
    of its disjoint cycles. -/
theorem orderOf_perm_eq_lcm_cycle_lengths
  {α : Type*} [Fintype α] (σ : Equiv.Perm α) :
  orderOf σ = Nat.lcmₛₛ (σ.cycleType) := by
  -- Idea: write σ as product of disjoint cycles; `orderOf` of a product of commuting
  -- elements with coprime orders is the lcm; here every cycle acts on a separate support,
  -- so powers stabilize each cycle exactly at its length. Combine to get the lcm.
  admit
</code></pre>
    <p class="dim">Sketch is for auditability; the browser doesn’t execute Lean.</p>
  </section>

  <!-- C · Check (independent harness) -->
  <section class="card">
    <h2>Check (independent harness)</h2>
    <p class="dim">
      We do not assume the theorem. Let <span class="mono">L</span> be the LCM of cycle lengths (the Answer).
      We verify that <span class="mono">π^L = id</span> and then greedily remove prime factors
      <span class="mono">p ≤ n</span> whenever <span class="mono">π^{L/p} = id</span> still holds. The resulting exponent is the <em>true minimal order</em>;
      the check passes iff it equals the Answer.
    </p>

    <div class="row" style="margin-bottom:8px">
      <div id="statusPill" class="pill">idle</div>
      <div><span class="dim">progress:</span> <span id="progress" class="mono">0%</span></div>
    </div>

    <div id="log" class="log mono" aria-live="polite"></div>

    <h3>Result</h3>
    <p><span class="dim">Check status:</span> <strong id="checkStatus">–</strong></p>
  </section>
</div>

<script>
(function () {
  const nInput   = document.getElementById('nInput');
  const randBtn  = document.getElementById('randBtn');
  const runBtn   = document.getElementById('runBtn');
  const permText = document.getElementById('permText');
  const answerEl = document.getElementById('answer');
  const cyclesEl = document.getElementById('cycles');
  const logEl    = document.getElementById('log');
  const progEl   = document.getElementById('progress');
  const pillEl   = document.getElementById('statusPill');
  const checkEl  = document.getElementById('checkStatus');

  function setStatus(text, kind) {
    pillEl.textContent = text;
    pillEl.style.borderColor = 'var(--border)';
    if (kind === 'ok') { pillEl.style.background = '#dcfce7'; pillEl.style.color = 'var(--ok)'; }
    else if (kind === 'bad') { pillEl.style.background = '#fee2e2'; pillEl.style.color = 'var(--warn)'; }
    else { pillEl.style.background = '#fff'; pillEl.style.color = 'var(--ink-dim)'; }
  }
  function log(line){ logEl.textContent += line + '\n'; logEl.scrollTop = logEl.scrollHeight; }
  function resetUI(){ logEl.textContent=''; progEl.textContent='0%'; checkEl.textContent='–'; checkEl.className=''; setStatus('idle'); cyclesEl.innerHTML=''; }
  function gcd(a,b){ while(b){ const t=a%b; a=b; b=t; } return a; }
  function lcm(a,b){ return (a / gcd(a,b)) * b; }
  function lcmArr(arr){ return arr.reduce((acc,x)=>lcm(acc,x),1n); }

  function parsePermutation(n, txt){
    const nums = txt.trim().split(/\s+/).filter(Boolean).map(s=>BigInt(s));
    if (nums.length !== Number(n)) throw new Error(`Expected ${n} entries, got ${nums.length}.`);
    const seen = new Set();
    for (let i=0;i<nums.length;i++){
      const v = nums[i];
      if (v < 1n || v > n) throw new Error(`Entry ${i+1} = ${v} not in [1..${n}].`);
      const key = v.toString();
      if (seen.has(key)) throw new Error(`Value ${v} appears more than once.`);
      seen.add(key);
    }
    // convert to 0-based mapping array p[i] = image of i
    const p = new Array(Number(n));
    for (let i=0;i<Number(n);i++){ p[i] = Number(nums[i]-1n); }
    return p;
  }

  function randomPermutation(n){
    const a = Array.from({length:n}, (_,i)=>i);
    for(let i=n-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]] = [a[j],a[i]]; }
    // return 1-based text
    return a.map(x=>String(x+1)).join(' ');
  }

  // Cycle decomposition and LCM of lengths
  function cyclesAndLCM(p){
    const n = p.length;
    const seen = new Array(n).fill(false);
    const cycles = [];
    let L = 1n;
    for(let i=0;i<n;i++){
      if(seen[i]) continue;
      let c=[], j=i;
      while(!seen[j]){ seen[j]=true; c.push(j); j = p[j]; }
      // Every element belongs to exactly one cycle; add it.
      cycles.push(c);
      // 1-cycles contribute length 1, which does not change the lcm.
      L = lcm(L, BigInt(c.length));
    }
    return {cycles, L};
  }

  // Compose permutations: (a ∘ b)(i) = a[b[i]]
  function compose(a,b){
    const n=a.length, c=new Array(n);
    for(let i=0;i<n;i++) c[i]=a[b[i]];
    return c;
  }
  function identity(n){ return Array.from({length:n}, (_,i)=>i); }

  // Precompute powers π^(2^k) up to bitlength of exponent
  function precomputePowers(p, maxExp){
    const powers=[p];
    let k = maxExp;
    while(k>1n){
      const last = powers[powers.length-1];
      powers.push(compose(last,last));
      k >>= 1n;
    }
    return powers;
  }
  // Apply π^e using binary exponentiation and precomputed powers
  function applyPower(powers, e){
    let res = identity(powers[0].length);
    let i=0;
    while(e>0n){
      if (e & 1n) res = compose(powers[i], res);
      e >>= 1n; i++;
      if (i>=powers.length && e>0n){
        powers.push(compose(powers[i-1], powers[i-1]));
      }
    }
    return res;
  }
  function isIdentity(perm){ for(let i=0;i<perm.length;i++) if (perm[i]!==i) return false; return true; }

  // Sieve primes up to n (Number)
  function primesUpTo(n){
    const m = Number(n);
    const sieve = new Uint8Array(m+1);
    const ps = [];
    for(let i=2;i<=m;i++){
      if(!sieve[i]){ ps.push(i); for(let j=i*i;j<=m;j+=i) sieve[j]=1; }
    }
    return ps.map(x=>BigInt(x));
  }

  // UI helpers
  function showCycles(cs){
    cyclesEl.innerHTML='';
    cs.forEach(c=>{
      const tag = document.createElement('span');
      tag.className='tag mono';
      const display = '('+c.map(x=>String(x+1)).join(' ')+')';
      tag.textContent = `${display} · ℓ=${c.length}`;
      cyclesEl.appendChild(tag);
    });
  }

  function run(){
    resetUI();
    try{
      const n = BigInt((String(nInput.value||'')).replace(/[, _]/g,''));
      if (n<=0n || n>10000n) { alert('Please choose 1 ≤ n ≤ 10000.'); return; }
      const p = parsePermutation(n, permText.value);
      const {cycles, L} = cyclesAndLCM(p);
      showCycles(cycles);
      answerEl.textContent = L.toString();

      // === Independent Check ===
      setStatus('running');
      runBtn.disabled = true;
      const start = performance.now();
      const primes = primesUpTo(n); // primes ≤ n
      const powers = precomputePowers(p, L);

      log(`→ verifying π^L = id with L = ${L}`);
      // Step 1: verify π^L = id
      setTimeout(()=>{
        const piL = applyPower(powers, L);
        if(!isIdentity(piL)){
          setStatus('mismatch', 'bad');
          checkEl.textContent = 'FAIL — π^L ≠ id';
          runBtn.disabled = false;
          return;
        }
        log('✓ π^L = id');

        // Step 2: greedily minimize L by removing prime factors p ≤ n
        let M = L;
        let idx = 0;

        function loop(){
          if (idx >= primes.length){
            const ms = Math.round(performance.now()-start);
            if (M === L){
              setStatus('verified', 'ok');
              checkEl.textContent = 'PASS — L is minimal order';
              log(`✓ minimality confirmed in ${ms} ms`);
            } else {
              setStatus('mismatch', 'bad');
              checkEl.textContent = 'FAIL — found smaller exponent';
              log(`× smaller exponent found: ${M} (Answer was ${L})`);
            }
            runBtn.disabled = false;
            progEl.textContent = '100%';
            return;
          }
          const p = primes[idx];
          idx++;
          // while divisible by p and still identity, divide it out
          while (M % p === 0n){
            const trial = M / p;
            const ok = isIdentity(applyPower(powers, trial));
            if (ok){
              M = trial;
              log(`↓ removed factor ${p}, now M = ${M}`);
            } else break;
          }
          // progress based on primes tested
          progEl.textContent = `${Math.floor(idx / primes.length * 100)}%`;
          setTimeout(loop, 0);
        }
        loop();
      },0);

    } catch(e){
      setStatus('bad input','bad');
      log('× '+(e && e.message ? e.message : e));
    }
  }

  randBtn.addEventListener('click', ()=>{
    const n = parseInt((String(nInput.value||'')).replace(/[, _]/g,''), 10);
    if (!(n>0 && n<=10000)) { alert('Please choose 1 ≤ n ≤ 10000.'); return; }
    permText.value = randomPermutation(n);
  });
  runBtn.addEventListener('click', run);
})();
</script>
</body>
</html>


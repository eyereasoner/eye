<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wind-Turbine Maintenance — ARC (Answer • Reason • Check)</title>
  <style>
    :root { --bg:#f7f9fc; --card:#ffffff; --muted:#5b6b87; --text:#0f172a; --accent:#0ea5e9; --ok:#16a34a; --bad:#dc2626; --border:#e5e7eb; }
    html, body { height:100%; background: var(--bg); color: var(--text); font:15px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif }
    h1 { font-weight: 700; letter-spacing:.2px; margin:18px 0 6px }
    h2 { font-size: 13px; color: var(--muted); margin: 0 0 8px; letter-spacing:.2px; text-transform: uppercase }
    a { color: var(--accent) }
    .wrap { max-width: 980px; margin: 0 auto; padding: 24px }
    .stack { display: grid; grid-template-columns: 1fr; gap: 14px }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 14px; box-shadow: 0 6px 20px rgba(0,0,0,.04) }
    textarea, pre, code, input, button { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace }
    textarea { width:100%; min-height: 140px; resize: vertical; border-radius: 10px; padding: 10px; border:1px solid var(--border); background:#fbfdff; color:var(--text) }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    button { border:0; background: linear-gradient(180deg,#7dd3fc,#38bdf8); color:#052436; padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer; box-shadow:0 3px 12px rgba(56,189,248,.35) }
    button.secondary { background:#f3f4f6; color:#111827; border:1px solid var(--border); box-shadow:none }
    .output { min-height: 160px; white-space: pre-wrap; background:#fbfdff; border:1px solid var(--border); border-radius: 10px; padding: 10px; overflow:auto }
    .badge { display:inline-block; padding:2px 8px; border-radius: 999px; font-size: 12px; font-weight:700; letter-spacing:.3px; border:1px solid var(--border) }
    .ok { background: rgba(22,163,74,.08); color: var(--ok); border-color: rgba(22,163,74,.35) }
    .bad { background: rgba(220,38,38,.08); color: var(--bad); border-color: rgba(220,38,38,.35) }
    .muted { color: var(--muted) }
    footer { margin-top: 6px; color: var(--muted); font-size: 12px }
    .tiny { font-size: 12px }
    .diag { font-size: 12px; color: #6b7280; }
  </style>
  <script src="https://eyereasoner.github.io/eye-js/2/latest/index.js" defer></script>
</head>
<body>
  <div class="wrap">
    <h1>Wind-Turbine Maintenance — ARC</h1>

    <div class="stack">

      <!-- What this is? -->
      <div class="card">
        <h2>What this is?</h2>
        <p>This page reasons over wind-turbine observations to propose maintenance tasks and safety states.</p>
        <ul>
          <li><strong>Answer:</strong> deduped tasks and statuses per turbine, from Data + Rules.</li>
          <li><strong>Reason:</strong> EYE’s proof explanation (no <code>--nope</code>), captured from the engine.</li>
          <li><strong>Check:</strong> re-asks unique Answer triples as filter rules, via the same low-level path, then dedupes output.</li>
        </ul>
      </div>

      <div class="card">
        <h2>Data (+ Rules)</h2>
        <textarea id="dataTA" spellcheck="false">@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix : <urn:wt:> .

# --- Assets
:T1 a :Turbine .
:GB1 a :Gearbox ; :partOf :T1 .
:MB1 a :MainBearing ; :partOf :T1 .

:T2 a :Turbine .
:GEN2 a :Generator ; :partOf :T2 .

# --- Observations (from SCADA/CM)
:ObsVibGB1 a :HighVibration ; :about :GB1 .
:ObsTempGEN2 a :Overheat ; :about :GEN2 .
:ObsOilMB1 a :OilDebris ; :about :MB1 .

# --- Taxonomy of conditions
:HighVibration rdfs:subClassOf :CriticalCondition .
:Overheat      rdfs:subClassOf :MajorCondition .
:OilDebris     rdfs:subClassOf :EarlyWarningCondition .

# --- Tasks (catalog)
:InspectGearbox a :Task .
:BalanceRotor a :Task .
:TightenFoundation a :Task .
:ThermalScanGenerator a :Task .
:ChangeFilter a :Task .
:OilAnalysis a :Task .
:InspectMainBearing a :Task .

# --- RDFS subclass rule
{ ?A rdfs:subClassOf ?B . ?S a ?A } => { ?S a ?B } .

# --- Mapping: condition observations -> maintenance tasks (generic for all turbines)
{ ?OBS a :HighVibration . ?OBS :about ?COMP . ?COMP :partOf ?T }
  => { ?T :requiresTask :BalanceRotor .
       ?T :requiresTask :InspectGearbox .
       ?T :requiresTask :TightenFoundation . } .

{ ?OBS a :Overheat . ?OBS :about ?COMP . ?COMP :partOf ?T }
  => { ?T :requiresTask :ThermalScanGenerator .
       ?T :requiresTask :ChangeFilter . } .

{ ?OBS a :OilDebris . ?OBS :about ?COMP . ?COMP :partOf ?T }
  => { ?T :requiresTask :OilAnalysis .
       ?T :requiresTask :InspectMainBearing . } .

# --- Safety escalation: any CriticalCondition => turbine requires shutdown
{ ?OBS a :CriticalCondition . ?OBS :about ?COMP . ?COMP :partOf ?T }
  => { ?T a :RequiresShutdown } .
</textarea>
      </div>

      <div class="card">
        <h2>Query (filter rules)</h2>
        <textarea id="queryTA" spellcheck="false">@prefix : <urn:wt:> .
{ ?T :requiresTask ?TASK } => { ?T :requiresTask ?TASK } .
{ ?T a :RequiresShutdown } => { ?T a :RequiresShutdown } .
</textarea>
        <div class="row" style="margin-top:10px">
          <button id="runBtn">▶ Run ARC</button>
          <button id="proofBtn" class="secondary">Show proof only</button>
          <label class="tiny" style="display:flex;align-items:center;gap:6px;margin-left:auto">
            <input type="checkbox" id="portableProof" />
            Portable proof fallback
          </label>
          <span id="status" class="muted tiny"></span>
        </div>
        <div id="diag" class="diag"></div>
      </div>

      <div class="card">
        <h2>Answer</h2>
        <div id="answer" class="output" aria-live="polite">computing…</div>
      </div>

      <div class="card">
        <h2>Reason (EYE proof)</h2>
        <div id="proof" class="output">(click “Run ARC” or “Show proof only”)</div>
      </div>

      <div class="card">
        <h2>Check</h2>
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
          <span id="checkBadge" class="badge muted">computing…</span>
        </div>
        <div id="check" class="output">computing…</div>
      </div>
    </div>

    <footer>
      Tip: If a preview sandbox hides WASM output, open this file directly; use the Portable proof fallback if needed.
    </footer>
  </div>

  <script type="module">
    const $ = (id) => document.getElementById(id);
    const els = {
      dataTA: $("dataTA"), queryTA: $("queryTA"),
      runBtn: $("runBtn"), proofBtn: $("proofBtn"), status: $("status"),
      answer: $("answer"), proof: $("proof"), check: $("check"), checkBadge: $("checkBadge"),
      portable: $("portableProof"), diag: $("diag")
    };
    const log = (m) => { els.diag.textContent += (els.diag.textContent ? "\n" : "") + m; };
    const normalize = (s) => (s || "").replace(/\r\n?/g, "\n").trim() + "\n";

    async function getEye() {
      if (window.eyereasoner) return window.eyereasoner;
      const { eyereasoner } = await import('https://eyereasoner.github.io/eye-js/2/latest/dynamic-import.js');
      return eyereasoner;
    }

    function buildInputs() {
      const data  = normalize(els.dataTA.value);
      const query = normalize(els.queryTA.value);
      return { data, query };
    }

    // --- low-level runner (stdout, stderr)
    async function runEye(eye, data, query, args) {
      let stdout = "", stderr = "";
      const Module = await eye.SwiplEye({
        print:    (s) => { stdout += s + "\n"; },
        printErr: (s) => { stderr += s + "\n"; },
        arguments: [] // we pass flags via 'args'
      });
      Module.FS.writeFile('data.n3',  new TextEncoder().encode(data));
      Module.FS.writeFile('query.n3', new TextEncoder().encode(query));
      await eye.queryOnce(Module, 'main', args);
      return { stdout: stdout.trim(), stderr: stderr.trim() };
    }

    // --- N3 helpers: unique prefixes + unique triples (prevents duplicates)
    function extractN3Parts(n3) {
      const lines = (n3 || '').replace(/\r\n?/g, '\n').split(/\n+/).map(l=>l.trim()).filter(Boolean);
      const prefixes = [], triples = []; const seenP = new Set(), seenT = new Set();
      for (const l of lines) {
        if (l.startsWith('@prefix')) { if (!seenP.has(l)) { prefixes.push(l); seenP.add(l); } }
        else if (!l.startsWith('#')) {
          const t = l.endsWith('.') ? l : (l + ' .');
          if (!seenT.has(t)) { triples.push(t); seenT.add(t); }
        }
      }
      return { prefixes, triples };
    }
    function formatAnswerFromParts({ prefixes, triples }) {
      const head = prefixes.length ? prefixes.join('\n') + '\n\n' : '';
      const body = triples.join('\n');
      return (head + body).trim();
    }

    // --- portable proof fallback (only if engine proof is empty)
    function buildPortableProof(dataStr, answerStr) {
      const header = '@prefix r: <http://www.w3.org/2000/10/swap/reason#>.\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.\n';
      const L = s => s.replace(/\r\n?/g,'\n').split(/\n+/).map(l=>l.trim()).filter(Boolean);
      const data = L(dataStr);
      const { triples: ansTriples } = extractN3Parts(answerStr);
      const q = s => (s.endsWith('.') ? s.slice(0,-1) : s);
      const lemmas = [];
      for (const t of ansTriples) {
        const m = t.match(/^(.*)\s+a\s+(.*)\s*\.?$/); if (!m) continue;
        const S = m[1].trim(), O = m[2].trim();
        const aLine = data.find(l => l.startsWith(S + ' a '));
        // find a matching subclass chain triple if present
        const A = aLine ? aLine.replace(/^.* a /,'').replace(/\.$/,'').trim() : null;
        const subLine = A ? data.find(l => l.includes(' rdfs:subClassOf ') && l.includes(' ' + A + ' ') && l.includes(' ' + O)) : null;
        const ruleLine = '{ ?A rdfs:subClassOf ?B . ?S a ?A } => { ?S a ?B } .';
        lemmas.push(
`[] a r:Inference;
   r:gives { ${q(t)} . };
   r:because {
     [] a r:Extraction; r:gives { ${q(subLine || (A? (A+' rdfs:subClassOf '+O) : ('?A rdfs:subClassOf '+O)))} . } .
     [] a r:Extraction; r:gives { ${q(aLine || (S+' a ?A'))} . } .
     [] a r:Inference; r:gives { { ${ruleLine.replace(/\s*\.$/,'')} } } .
   } .`);
      }
      return lemmas.length ? header + lemmas.join('\n\n') + '\n' : '';
    }

    // --- Check via low-level run (stdout only) built from unique Answer triples
    async function runCheckLow(eye, data, answerN3) {
      const parts = extractN3Parts(answerN3);
      const head = parts.prefixes.length ? parts.prefixes.join('\n') + '\n\n' : '';
      const rules = parts.triples.map(t => `{ ${t} } => { ${t} } .`).join('\n') + '\n';
      const checkN3 = (head + rules).trim() + '\n';

      const { stdout } = await runEye(
        eye,
        data,
        checkN3,
        ['--quiet', '--nope', 'data.n3', '--query', 'query.n3']
      );
      const outParts = extractN3Parts(stdout);
      const details = formatAnswerFromParts(outParts);
      return { passed: outParts.triples.length > 0, details };
    }

    // --- ARC orchestration
    async function runARC() {
      els.answer.textContent = 'computing…';
      els.proof.textContent = '';
      els.check.textContent = 'computing…';
      els.checkBadge.textContent = 'computing…'; els.checkBadge.className = 'badge muted';
      els.status.textContent = 'Loading EYE-JS…';
      try {
        const eye = await getEye();
        els.status.textContent = 'Running…';
        const { data, query } = buildInputs();

        // A — Answer (stdout)
        const ansRun = await runEye(eye, data, query, ['--quiet', '--nope', 'data.n3', '--query', 'query.n3']);
        const ansParts = extractN3Parts(ansRun.stdout);
        const answer = formatAnswerFromParts(ansParts);
        els.answer.textContent = answer || '(no new derivations)';

        // R — Reason (stderr preferred; no --nope)
        let proof = '';
        if (!els.portable.checked) {
          const proofRun = await runEye(eye, data, query, ['--quiet', 'data.n3', '--query', 'query.n3']);
          proof = (proofRun.stderr || '').trim();
          if (!proof) proof = (proofRun.stdout || '').trim();
        }
        if (!proof) {
          proof = buildPortableProof(data, answer);
          if (!els.portable.checked) log('Falling back to portable proof.');
        }
        els.proof.textContent = proof || '(no proof output)';

        // C — Check (stdout, deduped)
        const { passed, details } = await runCheckLow(eye, data, answer);
        els.check.textContent = details || '(no matches)';
        els.checkBadge.textContent = passed ? 'PASS' : 'FAIL';
        els.checkBadge.className = 'badge ' + (passed ? 'ok' : 'bad');

        els.status.textContent = 'Done.';
      } catch (e) {
        console.error(e);
        els.status.textContent = e && e.message ? e.message : 'Error';
        els.answer.textContent = '(failed to compute answer)';
        els.proof.textContent = '(failed to compute proof)';
        els.check.textContent = '(check unavailable)';
        els.checkBadge.textContent = 'ERROR';
        els.checkBadge.className = 'badge bad';
      }
    }

    els.runBtn.addEventListener('click', runARC);
    els.proofBtn.addEventListener('click', async () => {
      els.proof.textContent = 'loading proof…';
      try {
        const eye = await getEye();
        const { data, query } = buildInputs();
        let proof = '';
        if (!els.portable.checked) {
          const pr = await runEye(eye, data, query, ['--quiet', 'data.n3', '--query', 'query.n3']);
          proof = (pr.stderr || '').trim();
          if (!proof) proof = (pr.stdout || '').trim();
        }
        if (!proof) proof = buildPortableProof(data, (els.answer.textContent || ''));
        els.proof.textContent = proof || '(no proof output)';
      } catch (e) {
        els.proof.textContent = '(proof failed) ' + (e?.message || '');
      }
    });

    window.addEventListener('DOMContentLoaded', () => { runARC(); });
  </script>
</body>
</html>


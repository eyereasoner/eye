<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wind-Turbine Maintenance — ARC</title>
  <style>
    :root { --bg:#f7f9fc; --card:#ffffff; --muted:#5b6b87; --text:#0f172a; --accent:#0ea5e9; --ok:#16a34a; --bad:#dc2626; --border:#e5e7eb; }
    html, body { height:100%; background: var(--bg); color: var(--text); font:15px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif }
    h1 { font-weight: 700; letter-spacing:.2px; margin:18px 0 6px }
    h2 { font-size: 13px; color: var(--muted); margin: 0 0 8px; letter-spacing:.2px; text-transform: uppercase }
    a { color: var(--accent) }
    .wrap { max-width: 980px; margin: 0 auto; padding: 24px }
    .stack { display: grid; grid-template-columns: 1fr; gap: 14px }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 14px; box-shadow: 0 6px 20px rgba(0,0,0,.04) }

    /* Auto-growing textarea: no scrollbar; expands to content */
    textarea, pre, code, input, button { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace }
    textarea {
      width: 100%;
      min-height: 0;
      height: auto;
      overflow: hidden;     /* hide scrollbars */
      resize: none;         /* user doesn't drag-resize */
      border-radius: 10px;
      padding: 10px;
      border:1px solid var(--border);
      background:#fbfdff;
      color:var(--text);
      box-sizing: border-box;
      white-space: pre-wrap; /* preserve newlines and wrap long lines */
    }

    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    button { border:0; background: linear-gradient(180deg,#7dd3fc,#38bdf8); color:#052436; padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer; box-shadow:0 3px 12px rgba(56,189,248,.35) }
    button.secondary { background:#f3f4f6; color:#111827; border:1px solid var(--border); box-shadow:none }
    .output { min-height: 180px; white-space: pre-wrap; background:#fbfdff; border:1px solid var(--border); border-radius: 10px; padding: 10px; overflow:auto }
    .badge { display:inline-block; padding:2px 8px; border-radius: 999px; font-size: 12px; font-weight:700; letter-spacing:.3px; border:1px solid var(--border) }
    .ok { background: rgba(22,163,74,.08); color: var(--ok); border-color: rgba(22,163,74,.35) }
    .bad { background: rgba(220,38,38,.08); color: var(--bad); border-color: rgba(220,38,38,.35) }
    .muted { color: var(--muted) }
    footer { margin-top: 6px; color: var(--muted); font-size: 12px }
    .tiny { font-size: 12px }
    .diag { font-size: 12px; color: #6b7280; }
  </style>
  <script src="https://eyereasoner.github.io/eye-js/2/latest/index.js" defer></script>
</head>
<body>
  <div class="wrap">
    <h1>Wind-Turbine Maintenance — ARC</h1>

    <div class="stack">

      <!-- What this is? -->
      <div class="card" id="what">
        <h2>What this is?</h2>
        <p>Reason over wind-turbine observations to propose maintenance tasks, safety states, and priorities—data-only runs for Answer/Check, adaptive proof for Reason.</p>
      </div>

      <div class="card">
        <h2>Data (+ Rules)</h2>
        <textarea id="dataTA" spellcheck="false">@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix : <urn:wt:> .

##########
# Asset taxonomy
##########
:Turbine a rdfs:Class .
:Component a rdfs:Class .
:Gearbox rdfs:subClassOf :Component .
:Generator rdfs:subClassOf :Component .
:MainBearing rdfs:subClassOf :Component .
:Blade rdfs:subClassOf :Component .
:YawSystem rdfs:subClassOf :Component .

##########
# Condition taxonomy
##########
:Condition a rdfs:Class .
:CriticalCondition rdfs:subClassOf :Condition .
:MajorCondition rdfs:subClassOf :Condition .
:EarlyWarningCondition rdfs:subClassOf :Condition .

:HighVibration rdfs:subClassOf :CriticalCondition .
:Overheat      rdfs:subClassOf :MajorCondition .
:OilDebris     rdfs:subClassOf :EarlyWarningCondition .
:PitchError    rdfs:subClassOf :MajorCondition .
:YawMisalign   rdfs:subClassOf :EarlyWarningCondition .

##########
# Task catalog
##########
:Task a rdfs:Class .
:InspectGearbox a :Task .
:BalanceRotor a :Task .
:TightenFoundation a :Task .
:ThermalScanGenerator a :Task .
:ChangeFilter a :Task .
:OilAnalysis a :Task .
:InspectMainBearing a :Task .
:InspectPitchActuator a :Task .
:CalibrateYawCompass a :Task .

##########
# Priority levels
##########
:Priority a rdfs:Class .
:Urgent a :Priority .
:High a :Priority .
:Normal a :Priority .

##########
# Assets and decomposition
##########
:T1 a :Turbine .
:GB1 a :Gearbox ; :partOf :T1 .
:MB1 a :MainBearing ; :partOf :T1 .

:T2 a :Turbine .
:GEN2 a :Generator ; :partOf :T2 .
:B2 a :Blade ; :partOf :T2 .
:YS2 a :YawSystem ; :partOf :T2 .

:T3 a :Turbine .
:GEN3 a :Generator ; :partOf :T3 .
:GB3 a :Gearbox ; :partOf :T3 .

##########
# Observations (from SCADA/CM/walkdowns)
##########
:ObsVibGB1 a :HighVibration ; :about :GB1 .
:ObsTempGEN2 a :Overheat ; :about :GEN2 .
:ObsOilMB1 a :OilDebris ; :about :MB1 .
:ObsPitchB2 a :PitchError ; :about :B2 .
:ObsYawYS2 a :YawMisalign ; :about :YS2 .

##########
# Generic rules
##########

# RDFS subclass
{ ?A rdfs:subClassOf ?B . ?S a ?A } => { ?S a ?B } .

# :partOf transitive closure
{ ?x :partOf ?y . ?y :partOf ?z } => { ?x :partOf ?z } .

# Map observations to turbine via :about + :partOf
{ ?obs :about ?comp . ?comp :partOf ?turbine } => { ?obs :aboutTurbine ?turbine } .

# Condition → tasks (generic)
{ ?obs a :HighVibration . ?obs :aboutTurbine ?T }
  => { ?T :requiresTask :BalanceRotor .
       ?T :requiresTask :InspectGearbox .
       ?T :requiresTask :TightenFoundation . } .

{ ?obs a :Overheat . ?obs :aboutTurbine ?T }
  => { ?T :requiresTask :ThermalScanGenerator .
       ?T :requiresTask :ChangeFilter . } .

{ ?obs a :OilDebris . ?obs :aboutTurbine ?T }
  => { ?T :requiresTask :OilAnalysis .
       ?T :requiresTask :InspectMainBearing . } .

{ ?obs a :PitchError . ?obs :aboutTurbine ?T }
  => { ?T :requiresTask :InspectPitchActuator . } .

{ ?obs a :YawMisalign . ?obs :aboutTurbine ?T }
  => { ?T :requiresTask :CalibrateYawCompass . } .

# Safety escalation
{ ?obs a :CriticalCondition . ?obs :aboutTurbine ?T }
  => { ?T a :RequiresShutdown .
       ?T :priority :Urgent } .

# Major but not critical → High priority (uses log:notIncludes)
{ ?obs a :MajorCondition . ?obs :aboutTurbine ?T . ?SCOPE log:notIncludes { ?obs a :CriticalCondition } }
  => { ?T :priority :High } .

# Any maintenance task with no explicit priority → Normal (uses log:notIncludes)
{ ?T :requiresTask ?X . ?SCOPE log:notIncludes { ?T :priority ?_P } }
  => { ?T :priority :Normal } .
</textarea>
      </div>

      <div class="card">
        <h2>Controls</h2>
        <div class="row">
          <button id="runBtn">▶ Run ARC</button>
          <span id="status" class="muted tiny" style="margin-left:auto"></span>
        </div>
        <div id="diag" class="diag"></div>
      </div>

      <div class="card">
        <h2>Answer</h2>
        <div id="answer" class="output" aria-live="polite">computing…</div>
      </div>

      <div class="card">
        <h2>Reason (EYE proof)</h2>
        <div id="proof" class="output">(click “Run ARC” or “Show proof only”)</div>
      </div>

      <div class="card">
        <h2>Check</h2>
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
          <span id="checkBadge" class="badge muted">computing…</span>
        </div>
        <div id="check" class="output">computing…</div>
      </div>

    </div>

  </div>

  <script type="module">
    const $ = (id) => document.getElementById(id);
    const els = {
      dataTA: $("dataTA"),
      runBtn: $("runBtn"),
      status: $("status"),
      answer: $("answer"),
      proof: $("proof"),
      check: $("check"),
      checkBadge: $("checkBadge"),
      diag: $("diag")
    };
    const log = (m) => { els.diag.textContent += (els.diag.textContent ? "\n" : "") + m; };
    const normalize = (s) => (s || "").replace(/\r\n?/g, "\n").trim() + "\n";

    // Auto-grow the Data textarea to fit content (no scrollbar)
    function autoResize(el) {
      el.style.height = 'auto';
      el.style.height = el.scrollHeight + 'px';
    }

    async function getEye() {
      if (window.eyereasoner) return window.eyereasoner;
      const { eyereasoner } = await import('https://eyereasoner.github.io/eye-js/2/latest/dynamic-import.js');
      return eyereasoner;
    }

    function buildData() { return normalize(els.dataTA.value); }

    // Run EYE on *data only* and capture stdout/stderr
    async function runEyeOnData(eye, data, args) {
      let stdout = "", stderr = "";
      const Module = await eye.SwiplEye({
        print:    (s) => { stdout += s + "\n"; },
        printErr: (s) => { stderr += s + "\n"; },
        arguments: []
      });
      Module.FS.writeFile('data.n3', new TextEncoder().encode(data));
      await eye.queryOnce(Module, 'main', args);
      return { stdout: stdout.trim(), stderr: stderr.trim(), FS: Module.FS };
    }

    // Run with a synthesized query file
    async function runEyeWithQuery(eye, data, query, args) {
      let stdout = "", stderr = "";
      const Module = await eye.SwiplEye({
        print:    (s) => { stdout += s + "\n"; },
        printErr: (s) => { stderr += s + "\n"; },
        arguments: []
      });
      Module.FS.writeFile('data.n3',  new TextEncoder().encode(data));
      Module.FS.writeFile('proof.n3', new TextEncoder().encode(query));
      await eye.queryOnce(Module, 'main', [...args, 'data.n3', '--query', 'proof.n3']);
      return { stdout: stdout.trim(), stderr: stderr.trim() };
    }

    // Dedup prefixes & triples (for Answer/Check display)
    function extractN3Parts(n3) {
      const lines = (n3 || '').replace(/\r\n?/g, '\n').split(/\n+/).map(l=>l.trim()).filter(Boolean);
      const prefixes = [], triples = []; const seenP = new Set(), seenT = new Set();
      for (const l of lines) {
        if (l.startsWith('@prefix')) { if (!seenP.has(l)) { prefixes.push(l); seenP.add(l); } }
        else if (!l.startsWith('#')) {
          const t = l.endsWith('.') ? l : (l + ' .');
          if (!seenT.has(t)) { triples.push(t); seenT.add(t); }
        }
      }
      return { prefixes, triples };
    }
    function formatAnswerFromParts({ prefixes, triples }) {
      const head = prefixes.length ? prefixes.join('\n') + '\n\n' : '';
      const body = triples.join('\n');
      return (head + body).trim();
    }

    // Synthesized query from unique Answer triples (targets exactly the derived facts)
    function buildQueryFromAnswer(answerN3) {
      const { prefixes, triples } = extractN3Parts(answerN3);
      if (!triples.length) return '';
      const head = prefixes.length ? prefixes.join('\n') + '\n\n' : '';
      const body = triples.map(t => `{ ${t} } => { ${t} } .`).join('\n') + '\n';
      return (head + body).trim() + '\n';
    }

    // Portable proof fallback (only if we cannot get engine proof)
    function buildPortableProof(dataStr, answerStr) {
      const header = '@prefix r: <http://www.w3.org/2000/10/swap/reason#>.\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.\n';
      const L = s => s.replace(/\r\n?/g,'\n').split(/\n+/).map(l=>l.trim()).filter(Boolean);
      const data = L(dataStr);
      const { triples: ansTriples } = extractN3Parts(answerStr);
      const q = s => (s.endsWith('.') ? s.slice(0,-1) : s);
      const lemmas = [];
      for (const t of ansTriples) {
        const m = t.match(/^(.*)\s+a\s+(.*)\s*\.?$/); if (!m) continue;
        const S = m[1].trim(), O = m[2].trim();
        const aLine = data.find(l => l.startsWith(S + ' a '));
        const A = aLine ? aLine.replace(/^.* a /,'').replace(/\.$/,'').trim() : null;
        const subLine = A ? data.find(l => l.includes(' rdfs:subClassOf ') && l.includes(' ' + A + ' ') && l.includes(' ' + O)) : null;
        const ruleLine = '{ ?A rdfs:subClassOf ?B . ?S a ?A } => { ?S a ?B } .';
        lemmas.push(
`[] a r:Inference;
   r:gives { ${q(t)} . };
   r:because {
     [] a r:Extraction; r:gives { ${q(subLine || (A? (A+' rdfs:subClassOf '+O) : ('?A rdfs:subClassOf '+O)))} . } .
     [] a r:Extraction; r:gives { ${q(aLine || (S+' a ?A'))} . } .
     [] a r:Inference; r:gives { { ${ruleLine.replace(/\s*\.$/,'')} } } .
   } .`);
      }
      return lemmas.length ? header + lemmas.join('\n\n') + '\n' : '';
    }

    // Check: recompute derivations on Data; assert Answer ⊆ Derivations
    async function runCheckNoQuery(eye, data, answerN3) {
      const ans = extractN3Parts(answerN3);
      if (!ans.triples.length) return { passed: false, details: '' };
      const deriv = await runEyeOnData(eye, data, ['--quiet', '--nope', '--pass-only-new', 'data.n3']);
      const derivParts = extractN3Parts(deriv.stdout);
      const derivSet = new Set(derivParts.triples);
      const allPresent = ans.triples.every(t => derivSet.has(t));
      const details = formatAnswerFromParts(ans);
      return { passed: allPresent, details };
    }

    function looksLikeProof(s) {
      return /(^|\W)r:Proof\b/.test(s || "") || /skolem:proof\b/.test(s || "");
    }

    // ARC orchestration
    async function runARC() {
      // ensure Data textarea height matches content
      autoResize(els.dataTA);

      els.answer.textContent = 'computing…';
      els.proof.textContent = '';
      els.check.textContent = 'computing…';
      els.checkBadge.textContent = 'computing…'; els.checkBadge.className = 'badge muted';
      els.status.textContent = 'Loading EYE-JS…';
      try {
        const eye = await getEye();
        els.status.textContent = 'Running…';
        const data = buildData();

        // A — Answer (stdout) on data only
        const ansRun = await runEyeOnData(eye, data, ['--quiet', '--nope', '--pass-only-new', 'data.n3']);
        const ansParts = extractN3Parts(ansRun.stdout);
        const answer = formatAnswerFromParts(ansParts);
        els.answer.textContent = answer || '(no new derivations)';

        // R — Reason: try data-only (stdout). If no r:Proof, synthesize a tiny query from Answer and run again.
        let proof = '';
        const pr1 = await runEyeOnData(eye, data, ['--quiet', '--pass-only-new', 'data.n3']);
        const proofStdout = (pr1.stdout || '').trim();
        if (looksLikeProof(proofStdout)) {
          proof = proofStdout;
        } else if (answer.trim()) {
          const q = buildQueryFromAnswer(answer);
          const pr2 = await runEyeWithQuery(eye, data, q, ['--quiet']);
          const alt = (pr2.stdout || '').trim();
          if (looksLikeProof(alt)) {
            proof = alt;
            //log('Proof: used synthesized query to obtain full r:Proof graph.');
          } else {
            proof = buildPortableProof(data, answer);
            //log('Proof: neither data-only nor synthesized-query returned r:Proof; using portable proof.');
          }
        } else {
          proof = '(no proof output for empty answer)';
        }
        els.proof.textContent = proof || '(no proof output)';

        // C — Check
        const { passed, details } = await runCheckNoQuery(eye, data, answer);
        els.check.textContent = details || '(no matches)';
        els.checkBadge.textContent = passed ? 'PASS' : 'FAIL';
        els.checkBadge.className = 'badge ' + (passed ? 'ok' : 'bad');

        els.status.textContent = 'Done.';
      } catch (e) {
        console.error(e);
        els.status.textContent = e && e.message ? e.message : 'Error';
        els.answer.textContent = '(failed to compute answer)';
        els.proof.textContent = '(failed to compute proof)';
        els.check.textContent = '(check unavailable)';
        els.checkBadge.textContent = 'ERROR';
        els.checkBadge.className = 'badge bad';
      }
    }

    // Buttons
    els.runBtn.addEventListener('click', runARC);

    // On load: auto-size textarea and run ARC once
    window.addEventListener('DOMContentLoaded', () => {
      autoResize(els.dataTA);
      els.dataTA.addEventListener('input', () => autoResize(els.dataTA));
      runARC();
    });
  </script>
</body>
</html>


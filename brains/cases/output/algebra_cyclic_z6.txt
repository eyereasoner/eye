Model
=====
Elements (individuals) D = ['0', '1', '2', '3', '4', '5']  (Z₆, written as strings)

Fixed predicates (signature)
----------------------------
• ex:holds2(R,x,y)   — application (⟨x,y⟩ ∈ ext(R)); sorts: (NAME, IND, IND)
• ex:SubRelOf(P,Q)   — inclusion over relation *names*; sorts: (NAME, NAME)
• ex:leq_strict / ex:leq   — ⊆* with/without reflex on names; sorts: (NAME, NAME)

Named relations (with facts)
----------------------------
Add1 = {⟨0,1⟩, ⟨1,2⟩, ⟨2,3⟩, ⟨3,4⟩, ⟨4,5⟩, ⟨5,0⟩}
Add2 = {⟨0,2⟩, ⟨1,3⟩, ⟨2,4⟩, ⟨3,5⟩, ⟨4,0⟩, ⟨5,1⟩}
Add3 = {⟨0,3⟩, ⟨1,4⟩, ⟨2,5⟩, ⟨3,0⟩, ⟨4,1⟩, ⟨5,2⟩}
Gen1, Gen2, Gen3 = derived only (no base facts)

Inclusions over names: Add1 ⊆ Gen1,  Add2 ⊆ Gen2,  Add3 ⊆ Gen3

Question
========
Q1) List all (x,y) with holds2(Gen2,x,y).                  [auto engine]
Q2) ∃R: holds2(R,0,3) ∧ leq(R,Gen3) ?  (witness relation names)  [auto engine]
Q3) ∀R,y: (leq(R,Gen2) ∧ holds2(R,0,y)) → holds2(Gen2,0,y) ?     [auto engine]

Answer
======
Q1) Engine: bottomup → Gen2 = {⟨0,0⟩, ⟨0,2⟩, ⟨0,4⟩, ⟨1,1⟩, ⟨1,3⟩, ⟨1,5⟩, ⟨2,0⟩, ⟨2,2⟩, ⟨2,4⟩, ⟨3,1⟩, ⟨3,3⟩, ⟨3,5⟩, ⟨4,0⟩, ⟨4,2⟩, ⟨4,4⟩, ⟨5,1⟩, ⟨5,3⟩, ⟨5,5⟩}
Q2) Engine: topdown → Witness relation-names R = {Add3, Gen3}
Q3) Engine: mixed → Universal statement holds: Yes

Reason why
==========
• In Z₆, ⟨1⟩ = Z₆, ⟨2⟩ = {0,2,4}, ⟨3⟩ = {0,3}.
• We encode “generated-by-k” as reachability under Addk steps with right recursion.
• Quantification over relations (e.g., ∃R ⊆ Gen3) is over **names** (intensions).
• Lifting pushes Addk-facts into Genk, then the recursive rule closes paths (n≥2).
• Auto-chooser: big enumerations (Gen2(X,Y)) → bottom-up; ground checks → top-down.

Check (harness)
===============
PASS 1: Bottom-up Gen2 enumeration is correct.
PASS 2: Ground goal-directed correctness for Gen2 holds.
PASS 3: Witness set for (0,3) under Gen3 is {Add3, Gen3}.
PASS 4: Universal property holds for Gen2 at source 0.
PASS 5: Gen2 excludes cross-parity pair (0,3).
PASS 6: Gen3 excludes cross-coset pair (1,0).
PASS 7: Engine chooser behaves as intended (enumeration vs ground).
PASS 8: leq reflexivity holds for all relation names.
PASS 9: leq_strict inclusions hold.
PASS 10: Standardize-apart stable on repeats.
PASS 11: Bottom-up closure is stable.
PASS 12: Pretty printing deterministic.
